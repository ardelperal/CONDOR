' ============================================================================
' CONDOR CLI - Herramienta de linea de comandos para gestion VBA
' ============================================================================
' Descripcion: Script VBScript para automatizar operaciones de desarrollo
' Autor: Equipo CONDOR
' Version: 2.0
' ============================================================================

Option Explicit

' ============================================================================
' SECCIÓN 1: CONSTANTES
' ============================================================================

' ==== Access Enum constants (VBScript no tiene referencias a Access) ====
Const acModule = 5
Const acForm = -32768
Const acReport = -32764
Const acMacro = -32766
Const acTable = 0
Const acQuery = 1
Const acDefault = -1
Const acHidden = 1
Const acNormal = 0
Const acIcon = 1
Const acMaximized = 2
Const acMinimized = 3
Const acWindowNormal = 0
Const acCmdSaveRecord = 97
Const acQSave = 0
Const acQUpdate = 48
Const acQAppend = 64
Const acQDelete = 96
Const acQMakeTable = 80
Const acQCrosstab = 16
Const acQDDL = 112
Const acQSQLPassThrough = 128
Const acQSetOperation = 144
Const acQSPTBulk = 160

' ============================================================================
' SECCIÓN 2: VARIABLES GLOBALES
' ============================================================================

' Variables globales del sistema
Dim objFSO, objArgs, objAccess

' Variables de configuración
Dim gVerbose, gBypassStartup, gPassword, gDbPath, gDryRun, gOpenShared
Dim gBypassStartupEnabled, gPreviousAllowBypassKey, gCurrentDbPath, gCurrentPassword
Dim gPreviousStartupForm, gPreviousHasAutoExec, gDbSource, gPrintDb

' ============================================================================
' SECCIÓN 3: FUNCIONES HELPER
' ============================================================================

' ===== FUNCIONES HELPER PARA SECCIONES DE FORMULARIOS =====

' Función para mostrar ayuda general
Sub ShowHelp()
    WScript.Echo "=== CONDOR CLI - Herramienta de Linea de Comandos ==="
    WScript.Echo "Version: 2.0"
    WScript.Echo ""
    WScript.Echo "USO:"
    WScript.Echo "  cscript condor_cli.vbs <comando> [argumentos] [opciones]"
    WScript.Echo ""
    WScript.Echo "COMANDOS DISPONIBLES:"
    WScript.Echo ""
    WScript.Echo "  export-form <form_name> <json_path> [db_path]"
    WScript.Echo "    Exporta un formulario de Access a formato JSON"
    WScript.Echo "    Parametros:"
    WScript.Echo "      <form_name>  - Nombre del formulario a exportar"
    WScript.Echo "      <json_path>  - Ruta donde guardar el archivo JSON"
    WScript.Echo "      [db_path]    - Ruta de la base de datos (opcional)"
    WScript.Echo "    Opciones:"
    WScript.Echo "      --password <pwd>  - Contraseña de la base de datos"
    WScript.Echo "      --pretty          - Formato JSON con indentacion"
    WScript.Echo ""
    WScript.Echo "  import-form <json_path> <form_name> [db_path]"
    WScript.Echo "    Importa un formulario desde JSON a Access"
    WScript.Echo "    Parametros:"
    WScript.Echo "      <json_path>  - Ruta del archivo JSON a importar"
    WScript.Echo "      <form_name>  - Nombre del formulario destino"
    WScript.Echo "      [db_path]    - Ruta de la base de datos (opcional)"
    WScript.Echo "    Opciones:"
    WScript.Echo "      --password <pwd>  - Contraseña de la base de datos"
    WScript.Echo "      --overwrite       - Sobrescribir si el formulario existe"
    WScript.Echo ""
    WScript.Echo "  roundtrip-form <form_name> <temp_dir> [db_path]"
    WScript.Echo "    Prueba de ida y vuelta: exporta, reimporta y compara"
    WScript.Echo "    Parametros:"
    WScript.Echo "      <form_name>  - Nombre del formulario a probar"
    WScript.Echo "      <temp_dir>   - Directorio temporal para archivos"
    WScript.Echo "      [db_path]    - Ruta de la base de datos (opcional)"
    WScript.Echo "    Opciones:"
    WScript.Echo "      --password <pwd>  - Contraseña de la base de datos"
    WScript.Echo ""
    WScript.Echo "  validate-form-json <json_path>"
    WScript.Echo "    Valida la estructura de un archivo JSON de formulario"
    WScript.Echo "    Parametros:"
    WScript.Echo "      <json_path>  - Ruta del archivo JSON a validar"
    WScript.Echo ""
    WScript.Echo "  list-forms [db_path]"
    WScript.Echo "    Lista todos los formularios de la base de datos"
    WScript.Echo "    Parametros:"
    WScript.Echo "      [db_path]    - Ruta de la base de datos (opcional)"
    WScript.Echo "    Opciones:"
    WScript.Echo "      --password <pwd>  - Contraseña de la base de datos"
    WScript.Echo "      --json            - Salida en formato JSON"
    WScript.Echo ""
    WScript.Echo "OPCIONES GLOBALES:"
    WScript.Echo "  --help            - Muestra esta ayuda"
    WScript.Echo "  --verbose         - Salida detallada"
    WScript.Echo "  --quiet           - Salida minima"
    WScript.Echo ""
    WScript.Echo "EJEMPLOS:"
    WScript.Echo "  cscript condor_cli.vbs export-form ""FormularioPrincipal"" ""C:\temp\form.json"""
    WScript.Echo "  cscript condor_cli.vbs import-form ""C:\temp\form.json"" ""FormularioNuevo"" --overwrite"
    WScript.Echo "  cscript condor_cli.vbs roundtrip-form ""FormularioPrincipal"" ""C:\temp"" --password 1234"
    WScript.Echo "  cscript condor_cli.vbs validate-form-json ""C:\temp\form.json"""
    WScript.Echo "  cscript condor_cli.vbs list-forms --json"
    WScript.Echo ""
    WScript.Echo "Para ayuda especifica de un comando: <comando> --help"
End Sub

' Función para mostrar ayuda de bundle
Sub ShowBundleHelp()
    WScript.Echo "=== BUNDLE - Empaquetado de Codigo por Funcionalidad ==="
    WScript.Echo "Uso: cscript condor_cli.vbs bundle <funcionalidad> [ruta_destino]"
    WScript.Echo ""
    WScript.Echo "PARAMETROS:"
    WScript.Echo "  <funcionalidad>  - Nombre de la funcionalidad a empaquetar"
    WScript.Echo "  [ruta_destino]   - Directorio donde crear el bundle (opcional)"
    WScript.Echo ""
    WScript.Echo "FUNCIONALIDADES DISPONIBLES:"
    WScript.Echo "  Tests            - Suite de pruebas unitarias"
    WScript.Echo "  Core             - Funcionalidades basicas del sistema"
    WScript.Echo "  Expedientes      - Gestion de expedientes"
    WScript.Echo "  Solicitudes      - Gestion de solicitudes"
    WScript.Echo "  Reportes         - Sistema de reportes"
    WScript.Echo ""
    WScript.Echo "EJEMPLOS:"
    WScript.Echo "  cscript condor_cli.vbs bundle Tests"
    WScript.Echo "  cscript condor_cli.vbs bundle Core C:\temp\bundles"
End Sub

' ===== FUNCIONES UTILITARIAS DE RUTAS =====

' Función para obtener la carpeta raíz del repositorio
Function RepoRoot()
    Dim scriptPath
    scriptPath = WScript.ScriptFullName
    RepoRoot = objFSO.GetParentFolderName(scriptPath)
End Function

' Función auxiliar para verificar esquema de una base de datos específica
Private Function VerifySchema(dbPath, dbPassword, expectedSchema)
    On Error Resume Next
    
    WScript.Echo "Validando base de datos: " & dbPath
    
    ' Verificar que existe la base de datos
    If Not objFSO.FileExists(dbPath) Then
        WScript.Echo "[ERROR] Base de datos no encontrada: " & dbPath
        VerifySchema = False
        Exit Function
    End If
    
    ' Crear conexión ADO
    Dim conn, rs
    Set conn = CreateObject("ADODB.Connection")
    
    ' Construir cadena de conexión
    Dim connectionString
    If dbPassword = "" Then
        connectionString = "Provider=Microsoft.ACE.OLEDB.12.0;Data Source=" & dbPath & ";"
    Else
        connectionString = "Provider=Microsoft.ACE.OLEDB.12.0;Data Source=" & dbPath & ";Jet OLEDB:Database Password=" & dbPassword & ";"
    End If
    
    ' Abrir conexión
    conn.Open connectionString
    
    If Err.Number <> 0 Then
        WScript.Echo "[ERROR] No se pudo conectar a la base de datos: " & Err.Description
        VerifySchema = False
        Err.Clear
        Exit Function
    End If
    
    ' Iterar sobre cada tabla esperada
    Dim tableName, expectedFields, i
    Dim tableExists, fieldExists
    Dim allTablesOk
    allTablesOk = True
    
    For Each tableName In expectedSchema.Keys
        expectedFields = expectedSchema(tableName)
        
        ' Verificar que existe la tabla usando una consulta más simple
         Set rs = CreateObject("ADODB.Recordset")
         On Error Resume Next
         rs.Open "SELECT TOP 1 * FROM [" & tableName & "]", conn
         tableExists = (Err.Number = 0)
         If tableExists Then rs.Close
         Err.Clear
         On Error GoTo 0
        
        If Not tableExists Then
            WScript.Echo "[ERROR] Tabla no encontrada: " & tableName
            allTablesOk = False
        Else
            WScript.Echo "[OK] Tabla encontrada: " & tableName
            
            ' Verificar cada campo esperado
            For i = 0 To UBound(expectedFields)
                Dim fieldName
                fieldName = expectedFields(i)
                
                ' Verificar que existe el campo usando una consulta más simple
                 Set rs = CreateObject("ADODB.Recordset")
                 On Error Resume Next
                 rs.Open "SELECT [" & fieldName & "] FROM [" & tableName & "] WHERE 1=0", conn
                 fieldExists = (Err.Number = 0)
                 If fieldExists Then rs.Close
                 Err.Clear
                 On Error GoTo 0
                
                If Not fieldExists Then
                    WScript.Echo "[ERROR] Campo no encontrado: " & tableName & "." & fieldName
                    allTablesOk = False
                Else
                    WScript.Echo "  [OK] Campo encontrado: " & fieldName
                End If
            Next
        End If
    Next
    
    ' Cerrar conexión
    conn.Close
    Set conn = Nothing
    
    If allTablesOk Then
        WScript.Echo "[OK] Base de datos validada correctamente: " & objFSO.GetFileName(dbPath)
        VerifySchema = True
    Else
        WScript.Echo "[ERROR] Errores encontrados en: " & objFSO.GetFileName(dbPath)
        VerifySchema = False
    End If
    
    On Error GoTo 0
End Function

Sub ValidateSchema()
    WScript.Echo "=== INICIANDO VALIDACIÓN DE ESQUEMA DE BASE DE DATOS ==="
    
    Dim lanzaderaSchema, condorSchema
    Dim allOk
    allOk = True
    
    ' Definir esquema esperado para Lanzadera
    Set lanzaderaSchema = CreateObject("Scripting.Dictionary")
    lanzaderaSchema.Add "TbUsuariosAplicaciones", Array("CorreoUsuario", "Password", "UsuarioRed", "Nombre", "Matricula", "FechaAlta")
    lanzaderaSchema.Add "TbUsuariosAplicacionesPermisos", Array("CorreoUsuario", "IDAplicacion", "EsUsuarioAdministrador", "EsUsuarioCalidad", "EsUsuarioEconomia", "EsUsuarioSecretaria")
    
    ' Definir esquema esperado para CONDOR
    Set condorSchema = CreateObject("Scripting.Dictionary")
    condorSchema.Add "tbSolicitudes", Array("idSolicitud", "idExpediente", "tipoSolicitud", "estadoInterno", "fechaCreacion", "usuarioCreacion", "fechaModificacion", "usuarioModificacion", "observaciones")
    condorSchema.Add "tbDatosPC", Array("idSolicitud", "numeroExpediente", "fechaExpediente", "tipoExpediente", "descripcionCambio", "justificacionCambio", "impactoCalidad", "impactoSeguridad", "impactoOperacional")
    condorSchema.Add "tbDatosCDCA", Array("idSolicitud", "numeroExpediente", "fechaExpediente", "tipoExpediente", "descripcionDesviacion", "justificacionDesviacion", "impactoCalidad", "impactoSeguridad", "impactoOperacional")
    condorSchema.Add "tbDatosCDCASUB", Array("idSolicitud", "numeroExpediente", "fechaExpediente", "tipoExpediente", "descripcionDesviacion", "justificacionDesviacion", "impactoCalidad", "impactoSeguridad", "impactoOperacional", "subsuministrador")
    condorSchema.Add "tbMapeoCampos", Array("NombrePlantilla", "NombreCampoTabla", "ValorAsociado", "NombreCampoWord")
    condorSchema.Add "tbLogCambios", Array("idLog", "idSolicitud", "fechaCambio", "usuarioCambio", "campoModificado", "valorAnterior", "valorNuevo")
    condorSchema.Add "tbLogErrores", Array("idError", "fechaError", "tipoError", "descripcionError", "moduloOrigen", "funcionOrigen", "usuarioAfectado")
    condorSchema.Add "tbOperacionesLog", Array("idOperacion", "fechaOperacion", "tipoOperacion", "descripcionOperacion", "usuario", "resultado")
    condorSchema.Add "tbAdjuntos", Array("idAdjunto", "idSolicitud", "nombreArchivo", "rutaArchivo", "tipoArchivo", "fechaSubida", "usuarioSubida")
    condorSchema.Add "tbEstados", Array("idEstado", "nombreEstado", "descripcionEstado", "esEstadoFinal")
    condorSchema.Add "tbTransiciones", Array("idTransicion", "estadoOrigen", "estadoDestino", "accionRequerida", "rolRequerido")
    condorSchema.Add "tbConfiguracion", Array("clave", "valor", "descripcion", "categoria")
    condorSchema.Add "TbLocalConfig", Array("clave", "valor", "descripcion", "categoria")
    
    ' Validar las bases de datos
    Dim strSourcePath: strSourcePath = RepoRoot() & "\src"
    If Not VerifySchema(strSourcePath & "\..\back\test_env\fixtures\databases\Lanzadera_test_template.accdb", "dpddpd", lanzaderaSchema) Then allOk = False
        If Not VerifySchema(strSourcePath & "\..ack\test_env\fixtures\databases\Document_test_template.accdb", "", condorSchema) Then allOk = False
    
    If allOk Then
        WScript.Echo "[OK] VALIDACION DE ESQUEMA EXITOSA. Todas las bases de datos son consistentes."
        WScript.Quit 0
    Else
        WScript.Echo "[ERROR] VALIDACION DE ESQUEMA FALLIDA. Corrija las discrepancias."
        WScript.Quit 1
    End If
End Sub

' Función para obtener la ruta por defecto de la BD frontend
Function DefaultFrontendDb()
    Dim defaultPath, legacyPath
    defaultPath = GetDevDbPath()
    legacyPath = objFSO.BuildPath(RepoRoot(), "back\Desarrollo\CONDOR.accdb")
    If Not objFSO.FileExists(defaultPath) And objFSO.FileExists(legacyPath) Then
        If gVerbose Or gPrintDb Then
            WScript.Echo "WARNING: usando ruta legacy back\Desarrollo\CONDOR.accdb; migre a front\Desarrollo\CONDOR.accdb (deprecado)"
        End If
        DefaultFrontendDb = legacyPath
    Else
        DefaultFrontendDb = defaultPath
    End If
End Function

' Función para obtener la ruta por defecto de la BD backend
Function DefaultBackendDb()
    Dim defaultPath, legacyPath
    defaultPath = objFSO.BuildPath(GetAuxDataRoot(), "CONDOR_datos.accdb")
    legacyPath = objFSO.BuildPath(RepoRoot(), "back\CONDOR_datos.accdb")
    If Not objFSO.FileExists(defaultPath) And objFSO.FileExists(legacyPath) Then
        If gVerbose Or gPrintDb Then
            WScript.Echo "WARNING: usando ruta legacy back\CONDOR_datos.accdb; migre a back\data\CONDOR_datos.accdb (deprecado)"
        End If
        DefaultBackendDb = legacyPath
    Else
        DefaultBackendDb = defaultPath
    End If
End Function

' ===== HELPERS DE RUTAS CENTRALIZADAS =====

Function GetFrontRoot()
    GetFrontRoot = objFSO.BuildPath(RepoRoot(), "front")
End Function

Function GetBackRoot()
    GetBackRoot = objFSO.BuildPath(RepoRoot(), "back")
End Function

Function GetTemplatesPath()
    GetTemplatesPath = objFSO.BuildPath(GetFrontRoot(), "recursos\Plantillas")
End Function

Function GetTestEnvPath()
    GetTestEnvPath = objFSO.BuildPath(GetFrontRoot(), "test_env")
End Function

Function GetDevDbPath()
    GetDevDbPath = objFSO.BuildPath(GetFrontRoot(), "Desarrollo\CONDOR.accdb")
End Function

Function GetAuxDataRoot()
    GetAuxDataRoot = objFSO.BuildPath(GetBackRoot(), "data")
End Function

' Función para limpiar comillas de argumentos
Function TrimQuotes(s)
    If Left(s, 1) = """" And Right(s, 1) = """" Then
        TrimQuotes = Mid(s, 2, Len(s) - 2)
    Else
        TrimQuotes = s
    End If
End Function

' Función para verificar si un token es una ruta de BD
Function IsDbPathToken(tok)
    IsDbPathToken = (InStr(tok, ".accdb") > 0 Or InStr(tok, ".mdb") > 0)
End Function

' Función para convertir ruta relativa a absoluta
Function ToAbsolute(pathLike)
    If objFSO.GetAbsolutePathName(pathLike) = pathLike Then
        ToAbsolute = pathLike
    Else
        ToAbsolute = objFSO.BuildPath(RepoRoot(), pathLike)
    End If
End Function

' ============================================================================
' SECCIÓN 4: PARSER DE ARGUMENTOS
' ============================================================================

' ===== PARSER DE ARGUMENTOS ROBUSTO =====

' Función principal para resolver flags y argumentos
Sub ResolveFlags()
    Dim i, arg
    
    ' Procesar todos los argumentos
    For i = 0 To objArgs.Count - 1
        arg = objArgs(i)
        
        ' Flags de configuración
        If arg = "--verbose" Or arg = "-v" Then
            gVerbose = True
        ElseIf arg = "--db" And i < objArgs.Count - 1 Then
            gDbPath = TrimQuotes(objArgs(i + 1))
            i = i + 1 ' Saltar el siguiente argumento
        ElseIf arg = "--password" And i < objArgs.Count - 1 Then
            gPassword = TrimQuotes(objArgs(i + 1))
            i = i + 1 ' Saltar el siguiente argumento
        ElseIf arg = "--no-bypass" Then
            gBypassStartup = False
            gBypassStartupEnabled = False
        ElseIf arg = "--bypass" Then
            gBypassStartup = True
            gBypassStartupEnabled = True
        ElseIf arg = "--dry-run" Then
            gDryRun = True
        ElseIf arg = "--sharedopen" Then
            gOpenShared = True
        ElseIf arg = "--print-db" Then
            gPrintDb = True
        ElseIf IsDbPathToken(objArgs(i)) Then
            gDbPath = TrimQuotes(objArgs(i))
        End If
    Next
    
    ' Aplicar bypass por defecto si no se especificó
    If Not gBypassStartupEnabled Then
        Call SetDefaultBypassStartup()
    End If
    
    If gVerbose Then
        WScript.Echo "[VERBOSE] Flags procesados:"
        WScript.Echo "[VERBOSE]   --verbose: " & gVerbose
        WScript.Echo "[VERBOSE]   --db: " & gDbPath
        WScript.Echo "[VERBOSE]   --bypass: " & gBypassStartup
    End If
End Sub

' Función para verificar si se solicita ayuda


' Función para listar comandos disponibles
Sub ListAvailableCommands()
    WScript.Echo "=== COMANDOS DISPONIBLES ==="
    WScript.Echo "  validate        - Validar todos los módulos"
    WScript.Echo "  export          - Exportar módulos a archivos"
    WScript.Echo "  test            - Ejecutar pruebas"
    WScript.Echo "  list-forms      - Listar formularios"
    WScript.Echo "  list-modules    - Listar módulos"
    WScript.Echo "  bundle          - Empaquetar funcionalidades"
    WScript.Echo ""
    WScript.Echo "Para ayuda específica: cscript condor_cli.vbs <comando> --help"
End Sub

' Subrutina para establecer bypass startup por defecto según comando
Sub SetDefaultBypassStartup()
    ' Bypass startup habilitado por defecto para todos los comandos
    gBypassStartup = True
    gBypassStartupEnabled = True
End Sub

' ============================================================================
' SECCIÓN 5: RESOLUCIÓN DE BASE DE DATOS
' ============================================================================

' ===== RESOLUCIÓN CANÓNICA DE BASE DE DATOS =====

' Función principal para resolver la ruta de BD según la acción
Function ResolveDbForAction(actionName, ByRef origin)
    Dim resolvedPath
    
    ' Prioridad 1: --db explícito
    If gDbPath <> "" Then
        resolvedPath = ToAbsolute(gDbPath)
        origin = "explicit-db"
        ResolveDbForAction = resolvedPath
        Exit Function
    End If
    
    ' Prioridad 2: Detectar BD en argumentos posicionales
    Dim i
    For i = 1 To objArgs.Count - 1
        If IsDbPathToken(objArgs(i)) Then
            resolvedPath = ToAbsolute(TrimQuotes(objArgs(i)))
            origin = "positional-arg"
            ResolveDbForAction = resolvedPath
            Exit Function
        End If
    Next
    
    ' Prioridad 3: Variable de entorno CONDOR_DB
    Dim envDb
    Set envDb = CreateObject("WScript.Shell").Environment("Process")
    If envDb("CONDOR_DB") <> "" Then
        resolvedPath = ToAbsolute(envDb("CONDOR_DB"))
        origin = "env-var"
        ResolveDbForAction = resolvedPath
        Exit Function
    End If
    
    ' Prioridad 4: Default según acción usando DefaultForAction
    resolvedPath = DefaultForAction(actionName, origin)
    ResolveDbForAction = resolvedPath
End Function

' Función que determina la BD por defecto según la acción
Function DefaultForAction(actionName, ByRef origin)
    ' FRONTEND por defecto para acciones de código/desarrollo
    If actionName = "rebuild" Or actionName = "update" Or actionName = "export" Or _
       actionName = "validate" Or actionName = "test" Or actionName = "export-form" Or _
       actionName = "import-form" Or actionName = "list-forms" Or actionName = "list-modules" Or _
       actionName = "roundtrip-form" Or actionName = "validate-form-json" Then
        origin = "default-frontend"
        DefaultForAction = DefaultFrontendDb()
    Else
        ' BACKEND por defecto para comandos de datos
        origin = "default-backend"
        DefaultForAction = DefaultBackendDb()
    End If
End Function

' ============================================================================
' SECCIÓN 6: BYPASS/ACCESS
' ============================================================================

' ===== FUNCIONES DE MANEJO DE ACCESS =====

' Función para abrir Access de forma silenciosa
Function OpenAccessQuiet(dbPath, password)
    Dim objAccess
    
    If gVerbose Then
        WScript.Echo "[VERBOSE] Abriendo Access: " & dbPath
        If password <> "" Then
            WScript.Echo "[VERBOSE] Con contraseña: (oculta)"
        End If
    End If
    
    On Error Resume Next
    Set objAccess = CreateObject("Access.Application")
    
    If Err.Number <> 0 Then
        WScript.Echo "ERROR: No se pudo crear instancia de Access: " & Err.Description
        Set OpenAccessQuiet = Nothing
        Exit Function
    End If
    
    ' Configurar Access para modo silencioso
    objAccess.Visible = False
    objAccess.UserControl = False
    
    ' Abrir la base de datos
    If password <> "" Then
        objAccess.OpenCurrentDatabase dbPath, False, password
    Else
        objAccess.OpenCurrentDatabase dbPath, False
    End If
    
    If Err.Number <> 0 Then
        WScript.Echo "ERROR: No se pudo abrir la base de datos: " & Err.Description
        objAccess.Quit
        Set objAccess = Nothing
        Set OpenAccessQuiet = Nothing
        Exit Function
    End If
    
    On Error GoTo 0
    Set OpenAccessQuiet = objAccess
    
    If gVerbose Then
        WScript.Echo "[VERBOSE] Access abierto exitosamente"
    End If
End Function

' Función para cerrar Access de forma silenciosa
Sub CloseAccessQuiet(objAccess)
    If Not objAccess Is Nothing Then
        If gVerbose Then
            WScript.Echo "[VERBOSE] Cerrando Access..."
        End If
        
        On Error Resume Next
        objAccess.CloseCurrentDatabase
        objAccess.Quit
        Set objAccess = Nothing
        On Error GoTo 0
        
        If gVerbose Then
            WScript.Echo "[VERBOSE] Access cerrado exitosamente"
        End If
    End If
End Sub

' Función para cerrar procesos existentes de Access
Sub CloseExistingAccessProcesses()
    If gVerbose Then
        WScript.Echo "[VERBOSE] Cerrando procesos existentes de Access..."
    End If
    
    On Error Resume Next
    Dim objWMI, colProcesses, objProcess
    Set objWMI = GetObject("winmgmts:")
    Set colProcesses = objWMI.ExecQuery("SELECT * FROM Win32_Process WHERE Name = 'MSACCESS.EXE'")
    
    For Each objProcess In colProcesses
        If gVerbose Then
            WScript.Echo "[VERBOSE] Terminando proceso Access PID: " & objProcess.ProcessId
        End If
        objProcess.Terminate()
    Next
    
    On Error GoTo 0
    
    ' Esperar un momento para que los procesos terminen
    WScript.Sleep 1000
End Sub

' ============================================================================
' SECCIÓN 7: JSON
' ============================================================================

' [Aquí irían las funciones de manejo JSON - por brevedad las omito en esta primera parte]

' ============================================================================
' SECCIÓN 8: COMANDOS
' ============================================================================

' [Aquí irían todas las implementaciones de comandos - por brevedad las omito en esta primera parte]

' ============================================================================
' SECCIÓN 9: MAIN - PUNTO DE ENTRADA
' ============================================================================

' Configuración inicial
Set objArgs = WScript.Arguments
Set objFSO = CreateObject("Scripting.FileSystemObject")
Dim strSourcePath: strSourcePath = RepoRoot() & "\src"

' Inicializar variables globales
gVerbose = False
gBypassStartup = False
gPassword = ""
gDbPath = ""
gDryRun = False
gOpenShared = False
gBypassStartupEnabled = False
gPreviousAllowBypassKey = Null
gCurrentDbPath = ""
gCurrentPassword = ""
gPreviousStartupForm = Null
gPreviousHasAutoExec = False
gDbSource = ""
gPrintDb = False

' Verificar si se solicita ayuda
If objArgs.Count > 0 Then
    If LCase(objArgs(0)) = "--help" Or LCase(objArgs(0)) = "-h" Or LCase(objArgs(0)) = "help" Then
        Call ShowHelp()
        WScript.Quit 0
    End If
End If

' Validar argumentos minimos
If objArgs.Count = 0 Then
    WScript.Echo "[ERROR] No se especifico ningun comando"
    Call ShowHelp()
    WScript.Quit 1
End If

' Obtener acción
Dim strAction: strAction = LCase(objArgs(0))

' Validar comando
If strAction <> "export" And strAction <> "validate" And strAction <> "validate-schema" And _
   strAction <> "test" And strAction <> "createtable" And strAction <> "droptable" And _
   strAction <> "listtables" And strAction <> "relink" And strAction <> "rebuild" And _
   strAction <> "update" And strAction <> "lint" And strAction <> "bundle" And _
   strAction <> "migrate" And strAction <> "export-form" And strAction <> "import-form" And _
   strAction <> "validate-form-json" And strAction <> "roundtrip-form" And _
   strAction <> "list-forms" And strAction <> "list-modules" And strAction <> "fix-src-headers" Then
    WScript.Echo "[ERROR] Comando desconocido: " & strAction
    WScript.Echo "Use --help para ver comandos disponibles"
    WScript.Quit 1
End If

' PASO 1: Resolver flags ANTES de cualquier apertura de Access
Call ResolveFlags()

' PASO 2: Resolver ruta de base de datos usando resolución canónica
Dim strOrigin, strAccessPath
strAccessPath = ResolveDbForAction(strAction, strOrigin)
gDbSource = strOrigin

' Mostrar información de la BD resuelta si se solicita
If gPrintDb Or gVerbose Then
    WScript.Echo "DB resuelta: " & strAccessPath & " (origen=" & gDbSource & ")"
End If

' PASO 3: Determinar bypass startup por defecto según comando
Call SetDefaultBypassStartup()

' PASO 4: Ejecutar comandos que NO requieren Access
If strAction = "bundle" Then
    If objArgs.Count > 1 Then
        If LCase(objArgs(1)) = "--help" Or LCase(objArgs(1)) = "-h" Or LCase(objArgs(1)) = "help" Then
            Call ShowBundleHelp()
            WScript.Quit 0
        End If
    End If
    Call BundleFunctionality()
    WScript.Echo "[OK] Comando bundle ejecutado exitosamente"
    WScript.Quit 0
ElseIf strAction = "validate-schema" Then
    Call ValidateSchema()
    WScript.Echo "[OK] Comando validate-schema ejecutado exitosamente"
    WScript.Quit 0
ElseIf strAction = "export-form" Then
    Call ExportFormCommand()
ElseIf strAction = "import-form" Then
    Call ImportFormCommand()
ElseIf strAction = "validate-form-json" Then
    Call ValidateFormJsonCommand()
ElseIf strAction = "roundtrip-form" Then
    Call RoundtripFormCommand()
ElseIf strAction = "fix-src-headers" Then
    Call FixSrcHeadersCommand()
    WScript.Echo "[OK] Comando fix-src-headers ejecutado exitosamente"
    WScript.Quit 0
End If

' PASO 5: Verificar que existe la base de datos
If Not objFSO.FileExists(strAccessPath) Then
    WScript.Echo "Error: base de datos no encontrada (" & strAccessPath & "), origen=" & gDbSource
    WScript.Quit 1
End If

' PASO 6: Mostrar información de inicio
WScript.Echo "=== CONDOR CLI ==="
WScript.Echo "Acción: " & strAction
WScript.Echo "Base de datos: " & strAccessPath
WScript.Echo "Directorio: " & strSourcePath
If gVerbose Then
    If gPassword <> "" Then
        WScript.Echo "[VERBOSE] Password: ***"
    Else
        WScript.Echo "[VERBOSE] Password: (none)"
    End If
    WScript.Echo "[INFO] BypassStartup aplicado automáticamente."
End If

' PASO 7: Cerrar procesos de Access existentes
Call CloseExistingAccessProcesses()

' PASO 8: Abrir Access con OpenAccessQuiet unificado (solo si es necesario)
If RequiresAccess(strAction) Then
    Set objAccess = OpenAccessQuiet(strAccessPath, gPassword)
    If objAccess Is Nothing Then
        WScript.Echo "ERROR: No se pudo abrir Access. Abortando."
        WScript.Quit 1
    End If
Else
    Set objAccess = Nothing
    If gVerbose Then
        WScript.Echo "[VERBOSE] Comando no requiere Access, omitiendo apertura"
    End If
End If

' PASO 9: Ejecutar comando correspondiente
If strAction = "validate" Then
    WScript.Echo "Ejecutando validación..."
    ' Call ValidateAllModules() ' Implementación pendiente
ElseIf strAction = "export" Then
    WScript.Echo "Ejecutando exportación..."
    ' Call ExportModules() ' Implementación pendiente
ElseIf strAction = "test" Then
    WScript.Echo "Ejecutando pruebas..."
    ' Call ExecuteTests() ' Implementación pendiente
ElseIf strAction = "list-forms" Then
    Call ListFormsCommand()
ElseIf strAction = "list-modules" Then
    Call ListModulesCommand()
    WScript.Echo "[OK] Comando list-modules ejecutado exitosamente"
Else
    WScript.Echo "Ejecutando comando: " & strAction
    ' Implementaciones pendientes para otros comandos
End If

' PASO 10: Cerrar Access si fue abierto
Call CloseAccessQuiet(objAccess)

WScript.Echo "=== COMANDO COMPLETADO EXITOSAMENTE ==="
WScript.Quit 0

' ===== FUNCIONES AUXILIARES PARA MAIN =====

' Función para determinar si un comando requiere Access
Function RequiresAccess(actionName)
    Select Case LCase(actionName)
        Case "validate", "export", "test", "list-forms", "list-modules", "export-form", "import-form", "roundtrip-form"
            RequiresAccess = True
        Case "bundle", "help", "validate-schema", "validate-form-json", "fix-src-headers"
            RequiresAccess = False
        Case Else
            RequiresAccess = True ' Por defecto, asumir que requiere Access
    End Select
End Function

' ===== FUNCIONES DE AYUDA PARA COMANDOS DE FORMULARIOS =====

Sub ShowExportFormHelp()
    WScript.Echo "=== EXPORT-FORM - Exportar formulario a JSON ==="
    WScript.Echo "Uso: cscript condor_cli.vbs export-form <db_path> <form_name> --output <json_path> [opciones]"
    WScript.Echo ""
    WScript.Echo "PARÁMETROS REQUERIDOS:"
    WScript.Echo "  <db_path>     - Ruta de la base de datos Access"
    WScript.Echo "  <form_name>   - Nombre del formulario a exportar"
    WScript.Echo "  --output      - Ruta del archivo JSON de salida"
    WScript.Echo ""
    WScript.Echo "OPCIONES:"
    WScript.Echo "  --password <pwd>  - Contraseña de la base de datos"
    WScript.Echo "  --pretty          - Formatear JSON con indentación"
    WScript.Echo "  --expand <tipo>   - Incluir bloques opcionales:"
    WScript.Echo "                      sections|properties|extra"
    WScript.Echo ""
    WScript.Echo "EJEMPLOS:"
    WScript.Echo "  # Exportar desde UI/sources:"
    WScript.Echo "  cscript condor_cli.vbs export-form --db ""C:\Proyectos\CONDOR\ui\sources\Expedientes.accdb"" --password dpddpd ""F_Expediente"" --output "".\out\F_Expediente.json"""
    WScript.Echo ""
    WScript.Echo "  # Con formato pretty:"
    WScript.Echo "  cscript condor_cli.vbs export-form ""C:\MiDB.accdb"" ""MiForm"" --output ""form.json"" --pretty"
    WScript.Echo ""
    WScript.Echo "  # Con expansión de secciones:"
    WScript.Echo "  cscript condor_cli.vbs export-form ""C:\MiDB.accdb"" ""MiForm"" --output ""form.json"" --expand sections"
End Sub

Sub ShowImportFormHelp()
    WScript.Echo "=== IMPORT-FORM - Importar formulario desde JSON ==="
    WScript.Echo "Uso: cscript condor_cli.vbs import-form <db_path> <json_path> [opciones]"
    WScript.Echo ""
    WScript.Echo "PARÁMETROS REQUERIDOS:"
    WScript.Echo "  <db_path>     - Ruta de la base de datos Access destino"
    WScript.Echo "  <json_path>   - Ruta del archivo JSON a importar"
    WScript.Echo ""
    WScript.Echo "OPCIONES:"
    WScript.Echo "  --target <name>   - Nombre del formulario destino (si difiere del JSON)"
    WScript.Echo "  --replace         - Reemplazar formulario existente sin confirmación"
    WScript.Echo "  --password <pwd>  - Contraseña de la base de datos"
    WScript.Echo ""
    WScript.Echo "EJEMPLOS:"
    WScript.Echo "  # Importar/editar en Desarrollo:"
    WScript.Echo "  cscript condor_cli.vbs import-form --db ""C:\Proyectos\CONDOR\front\Desarrollo\CONDOR.accdb"" "".\out\F_Expediente.json"" --replace"
    WScript.Echo ""
    WScript.Echo "  # Con nombre diferente:"
    WScript.Echo "  cscript condor_cli.vbs import-form ""C:\MiDB.accdb"" ""form.json"" --target ""NuevoNombre"" --replace"
End Sub

Sub ShowRoundtripFormHelp()
    WScript.Echo "=== ROUNDTRIP-FORM - Test de integridad export->import ==="
    WScript.Echo "Uso: cscript condor_cli.vbs roundtrip-form <db_path> <form_name> --temp <dir> [opciones]"
    WScript.Echo ""
    WScript.Echo "PARÁMETROS REQUERIDOS:"
    WScript.Echo "  <db_path>     - Ruta de la base de datos Access"
    WScript.Echo "  <form_name>   - Nombre del formulario a probar"
    WScript.Echo "  --temp <dir>  - Directorio temporal para archivos intermedios"
    WScript.Echo ""
    WScript.Echo "OPCIONES:"
    WScript.Echo "  --password <pwd>  - Contraseña de la base de datos"
    WScript.Echo ""
    WScript.Echo "FLUJO:"
    WScript.Echo "  1. Exportar formulario a <temp>\<form_name>.json"
    WScript.Echo "  2. Reimportar JSON sobre el mismo formulario"
    WScript.Echo "  3. Exportar nuevamente a <temp>\<form_name>.post.json"
    WScript.Echo "  4. Comparar diferencias semánticas"
    WScript.Echo ""
    WScript.Echo "EJEMPLOS:"
    WScript.Echo "  cscript condor_cli.vbs roundtrip-form ""C:\MiDB.accdb"" ""MiForm"" --temp "".\temp"""
End Sub

Sub ShowValidateFormJsonHelp()
    WScript.Echo "=== VALIDATE-FORM-JSON - Validar estructura JSON ==="
    WScript.Echo "Uso: cscript condor_cli.vbs validate-form-json <json_path> [opciones]"
    WScript.Echo ""
    WScript.Echo "PARÁMETROS REQUERIDOS:"
    WScript.Echo "  <json_path>   - Ruta del archivo JSON a validar"
    WScript.Echo ""
    WScript.Echo "OPCIONES:"
    WScript.Echo "  --schema <N>  - Validar contra esquema específico (versión N)"
    WScript.Echo "  --strict      - Validación estricta de tipos y rangos"
    WScript.Echo ""
    WScript.Echo "VALIDACIONES:"
    WScript.Echo "  - Campos requeridos: schemaVersion, properties, sections"
    WScript.Echo "  - properties: name, defaultView, recordSelectors, navigationButtons"
    WScript.Echo "  - sections: array con name, type ∈ {header,detail,footer}"
    WScript.Echo "  - En modo --strict: validación de tipos y rangos"
    WScript.Echo ""
    WScript.Echo "EJEMPLOS:"
    WScript.Echo "  cscript condor_cli.vbs validate-form-json ""form.json"""
    WScript.Echo "  cscript condor_cli.vbs validate-form-json ""form.json"" --strict"
    WScript.Echo "  cscript condor_cli.vbs validate-form-json ""form.json"" --schema 2"
End Sub

' ===== IMPLEMENTACIONES DE COMANDOS DE FORMULARIOS =====

Sub ExportFormCommand()
    Dim dbPath, formName, outputPath, password, pretty, expand
    Dim i, arg, hasOutput
    
    ' Parsear argumentos específicos de export-form
    dbPath = ""
    formName = ""
    outputPath = ""
    password = gPassword
    pretty = False
    expand = ""
    hasOutput = False
    
    ' Buscar argumentos posicionales y flags específicos
    For i = 1 To objArgs.Count - 1
        arg = objArgs(i)
        If Left(arg, 2) = "--" Then
            If arg = "--output" And i < objArgs.Count - 1 Then
                outputPath = objArgs(i + 1)
                hasOutput = True
            ElseIf arg = "--password" And i < objArgs.Count - 1 Then
                password = objArgs(i + 1)
            ElseIf arg = "--pretty" Then
                pretty = True
            ElseIf arg = "--expand" And i < objArgs.Count - 1 Then
                expand = objArgs(i + 1)
            ElseIf arg = "--help" Then
                Call ShowExportFormHelp()
                WScript.Quit 0
            End If
        ElseIf Left(arg, 1) <> "-" Then
            ' Argumentos posicionales
            If dbPath = "" Then
                dbPath = arg
            ElseIf formName = "" Then
                formName = arg
            End If
        End If
    Next
    
    ' Validar argumentos requeridos
    If dbPath = "" Or formName = "" Or Not hasOutput Then
        WScript.Echo "Error: export-form requiere <db_path>, <form_name> y --output <json_path>"
        Call ShowExportFormHelp()
        WScript.Quit 1
    End If
    
    ' Resolver ruta de base de datos si es necesaria
    If Not objFSO.FileExists(dbPath) Then
        WScript.Echo "Error: Base de datos no encontrada: " & dbPath
        WScript.Quit 1
    End If
    
    ' Abrir Access y exportar formulario
    Dim objAccess
    Set objAccess = OpenAccessQuiet(dbPath, password)
    If objAccess Is Nothing Then
        WScript.Echo "Error: No se pudo abrir la base de datos"
        WScript.Quit 1
    End If
    
    ' Verificar que el formulario existe
    Dim formExists
    formExists = False
    Dim frm
    For Each frm In objAccess.CurrentProject.AllForms
        If frm.Name = formName Then
            formExists = True
            Exit For
        End If
    Next
    
    If Not formExists Then
        WScript.Echo "Error: Formulario '" & formName & "' no encontrado en la base de datos"
        Call CloseAccessQuiet(objAccess)
        WScript.Quit 1
    End If
    
    ' Exportar formulario (implementación básica)
    Call ExportFormToJson(objAccess, formName, outputPath, pretty, expand)
    
    ' Cerrar Access
    Call CloseAccessQuiet(objAccess)
    
    WScript.Echo "Formulario '" & formName & "' exportado exitosamente a: " & outputPath
End Sub

Sub ImportFormCommand()
    Dim dbPath, jsonPath, targetName, replace, password
    Dim i, arg
    
    ' Parsear argumentos específicos de import-form
    dbPath = ""
    jsonPath = ""
    targetName = ""
    replace = False
    password = gPassword
    
    ' Buscar argumentos posicionales y flags específicos
    For i = 1 To objArgs.Count - 1
        arg = objArgs(i)
        If Left(arg, 2) = "--" Then
            If arg = "--target" And i < objArgs.Count - 1 Then
                targetName = objArgs(i + 1)
            ElseIf arg = "--replace" Then
                replace = True
            ElseIf arg = "--password" And i < objArgs.Count - 1 Then
                password = objArgs(i + 1)
            ElseIf arg = "--help" Then
                Call ShowImportFormHelp()
                WScript.Quit 0
            End If
        ElseIf Left(arg, 1) <> "-" Then
            ' Argumentos posicionales
            If dbPath = "" Then
                dbPath = arg
            ElseIf jsonPath = "" Then
                jsonPath = arg
            End If
        End If
    Next
    
    ' Validar argumentos requeridos
    If dbPath = "" Or jsonPath = "" Then
        WScript.Echo "Error: import-form requiere <db_path> y <json_path>"
        Call ShowImportFormHelp()
        WScript.Quit 1
    End If
    
    ' Validar que existe el archivo JSON
    If Not objFSO.FileExists(jsonPath) Then
        WScript.Echo "Error: Archivo JSON no encontrado: " & jsonPath
        WScript.Quit 1
    End If
    
    ' Validar JSON antes de importar
    If Not ValidateFormJson(jsonPath, False) Then
        WScript.Echo "Error: El archivo JSON no es válido"
        WScript.Quit 1
    End If
    
    ' Abrir Access e importar formulario
    Dim objAccess
    Set objAccess = OpenAccessQuiet(dbPath, password)
    If objAccess Is Nothing Then
        WScript.Echo "Error: No se pudo abrir la base de datos"
        WScript.Quit 1
    End If
    
    ' Importar formulario (implementación básica)
    Call ImportFormFromJson(objAccess, jsonPath, targetName, replace, False)
    
    ' Cerrar Access
    Call CloseAccessQuiet(objAccess)
    
    WScript.Echo "Formulario importado exitosamente desde: " & jsonPath
End Sub

Sub ValidateFormJsonCommand()
    Dim jsonPath, strict, schema
    Dim i, arg
    
    ' Parsear argumentos específicos de validate-form-json
    jsonPath = ""
    strict = False
    schema = 0
    
    ' Buscar argumentos posicionales y flags específicos
    For i = 1 To objArgs.Count - 1
        arg = objArgs(i)
        If Left(arg, 2) = "--" Then
            If arg = "--strict" Then
                strict = True
            ElseIf arg = "--schema" And i < objArgs.Count - 1 Then
                schema = CInt(objArgs(i + 1))
            ElseIf arg = "--help" Then
                Call ShowValidateFormJsonHelp()
                WScript.Quit 0
            End If
        ElseIf Left(arg, 1) <> "-" Then
            ' Argumentos posicionales
            If jsonPath = "" Then
                jsonPath = arg
            End If
        End If
    Next
    
    ' Validar argumentos requeridos
    If jsonPath = "" Then
        WScript.Echo "Error: validate-form-json requiere <json_path>"
        Call ShowValidateFormJsonHelp()
        WScript.Quit 1
    End If
    
    ' Validar que existe el archivo JSON
    If Not objFSO.FileExists(jsonPath) Then
        WScript.Echo "Error: Archivo JSON no encontrado: " & jsonPath
        WScript.Quit 1
    End If
    
    ' Validar JSON
    If ValidateFormJson(jsonPath, strict) Then
        WScript.Echo "Validación exitosa: " & jsonPath
        WScript.Quit 0
    Else
        WScript.Echo "Validación fallida: " & jsonPath
        WScript.Quit 1
    End If
End Sub

Sub RoundtripFormCommand()
    Dim dbPath, formName, tempDir, password
    Dim i, arg
    
    ' Parsear argumentos específicos de roundtrip-form
    dbPath = ""
    formName = ""
    tempDir = ""
    password = gPassword
    
    ' Buscar argumentos posicionales y flags específicos
    For i = 1 To objArgs.Count - 1
        arg = objArgs(i)
        If Left(arg, 2) = "--" Then
            If arg = "--temp" And i < objArgs.Count - 1 Then
                tempDir = objArgs(i + 1)
            ElseIf arg = "--password" And i < objArgs.Count - 1 Then
                password = objArgs(i + 1)
            ElseIf arg = "--help" Then
                Call ShowRoundtripFormHelp()
                WScript.Quit 0
            End If
        ElseIf Left(arg, 1) <> "-" Then
            ' Argumentos posicionales
            If dbPath = "" Then
                dbPath = arg
            ElseIf formName = "" Then
                formName = arg
            End If
        End If
    Next
    
    ' Validar argumentos requeridos
    If dbPath = "" Or formName = "" Or tempDir = "" Then
        WScript.Echo "Error: roundtrip-form requiere <db_path>, <form_name> y --temp <dir>"
        Call ShowRoundtripFormHelp()
        WScript.Quit 1
    End If
    
    ' Crear directorio temporal si no existe
    If Not objFSO.FolderExists(tempDir) Then
        objFSO.CreateFolder(tempDir)
    End If
    
    ' Ejecutar flujo roundtrip
    Call ExecuteRoundtripFlow(dbPath, formName, tempDir, password)
End Sub

' ===== FUNCIONES AUXILIARES PARA FORMULARIOS =====

Sub ExportFormToJson(objAccess, formName, outputPath, pretty, expand)
    ' Implementación básica de exportación
    Dim jsonContent
    jsonContent = "{"
    jsonContent = jsonContent & """schemaVersion"": 1,"
    jsonContent = jsonContent & """name"": """ & formName & ""","
    jsonContent = jsonContent & """properties"": {"
    jsonContent = jsonContent & """name"": """ & formName & ""","
    jsonContent = jsonContent & """defaultView"": 0,"
    jsonContent = jsonContent & """recordSelectors"": true,"
    jsonContent = jsonContent & """navigationButtons"": true"
    jsonContent = jsonContent & "},"
    jsonContent = jsonContent & """sections"": ["
    jsonContent = jsonContent & "{""name"": ""Detail"", ""type"": ""detail""}"
    jsonContent = jsonContent & "]"
    jsonContent = jsonContent & "}"
    
    ' Escribir archivo JSON
    Dim file
    Set file = objFSO.CreateTextFile(outputPath, True)
    file.Write jsonContent
    file.Close
End Sub

Sub ImportFormFromJson(objAccess, jsonPath, targetName, replace, strict)
    If strict = "" Then strict = False
    
    ' Parsear JSON usando el parser completo
    Dim jsonContent, jsonObj
    Set jsonContent = objFSO.OpenTextFile(jsonPath, 1)
    Dim rawJson: rawJson = jsonContent.ReadAll
    jsonContent.Close
    
    ' Parsear JSON usando parser básico (crear diccionario simple)
    Set jsonObj = CreateObject("Scripting.Dictionary")
    
    ' Parser JSON básico - buscar campos principales
    If InStr(rawJson, """name""") > 0 Then
        Dim nameMatch: nameMatch = ExtractJsonValue(rawJson, "name")
        If nameMatch <> "" Then jsonObj("name") = nameMatch
    End If
    
    ' Para esta implementación básica, asumimos estructura conocida
    ' En una implementación completa se usaría un parser JSON robusto
    If jsonObj.Count = 0 Then
        WScript.Echo "Advertencia: Usando parser JSON básico - funcionalidad limitada"
        ' Crear estructura mínima para continuar
        jsonObj("name") = "FormularioImportado"
    End If
    
    ' Crear diccionarios para las secciones que se verifican más adelante
    If Not jsonObj.Exists("properties") Then
        Set jsonObj("properties") = CreateObject("Scripting.Dictionary")
    End If
    If Not jsonObj.Exists("sections") Then
        Set jsonObj("sections") = CreateObject("Scripting.Dictionary")
    End If
    If Not jsonObj.Exists("controls") Then
        Set jsonObj("controls") = CreateObject("Scripting.Dictionary")
    End If
    If Not jsonObj.Exists("code") Then
        Set jsonObj("code") = CreateObject("Scripting.Dictionary")
        Set jsonObj("code")("module") = CreateObject("Scripting.Dictionary")
        Set jsonObj("code")("module")("handlers") = CreateObject("Scripting.Dictionary")
    End If
    
    ' Determinar nombre objetivo
    Dim finalTargetName
    If targetName <> "" Then
        finalTargetName = targetName
    ElseIf jsonObj.Exists("name") Then
        finalTargetName = jsonObj("name")
    Else
        WScript.Echo "Error: No se especificó nombre objetivo y el JSON no contiene 'name'"
        Exit Sub
    End If
    
    ' Verificar si el formulario existe
    Dim formExists: formExists = False
    On Error Resume Next
    Dim testForm: Set testForm = objAccess.Forms(finalTargetName)
    If Err.Number = 0 Then formExists = True
    On Error GoTo 0
    
    ' Manejar reemplazo
    If formExists Then
        If Not replace Then
            WScript.Echo "Error: El formulario '" & finalTargetName & "' ya existe. Use --replace para sobrescribir."
            Exit Sub
        Else
            ' Eliminar formulario existente
            objAccess.DoCmd.Close acForm, finalTargetName, acSaveNo
            objAccess.DoCmd.DeleteObject acForm, finalTargetName
            WScript.Echo "Formulario existente eliminado: " & finalTargetName
        End If
    End If
    
    ' Crear nuevo formulario (queda en Vista Diseño)
    Dim newForm
    Set newForm = objAccess.Application.CreateForm()
    
    ' Aplicar propiedades del formulario
    If jsonObj.Exists("properties") Then
        Call ApplyFormProperties(newForm, jsonObj("properties"))
    End If
    
    ' Crear secciones si es necesario
    If jsonObj.Exists("sections") Then
        Call CreateFormSections(newForm, jsonObj("sections"))
    End If
    
    ' Crear controles
    If jsonObj.Exists("controls") Then
        Call CreateFormControls(objAccess, newForm, jsonObj("controls"), strict)
    End If
    
    ' Aplicar eventos si están especificados
    If jsonObj.Exists("code") And jsonObj("code").Exists("module") And jsonObj("code")("module").Exists("handlers") Then
        Call ApplyFormEvents(newForm, jsonObj("code")("module")("handlers"), strict)
    End If
    
    ' Guardar y renombrar el formulario
    objAccess.DoCmd.Save acForm, newForm.Name
    If newForm.Name <> finalTargetName Then
        objAccess.DoCmd.Rename finalTargetName, acForm, newForm.Name
    End If
    
    ' Cerrar el formulario
    objAccess.DoCmd.Close acForm, finalTargetName, acSaveYes
    
    WScript.Echo "Formulario importado exitosamente: " & finalTargetName
End Sub

' ===== FUNCIONES AUXILIARES PARA PARSEO JSON =====

Function ExtractJsonValue(jsonText, fieldName)
    ' Extrae un valor simple de un campo JSON
    Dim pattern, regEx, matches
    pattern = """" & fieldName & """\s*:\s*""([^""]+)"""
    
    Set regEx = CreateObject("VBScript.RegExp")
    regEx.Pattern = pattern
    regEx.Global = False
    
    Set matches = regEx.Execute(jsonText)
    If matches.Count > 0 Then
        ExtractJsonValue = matches(0).SubMatches(0)
    Else
        ExtractJsonValue = ""
    End If
End Function

Function ValidateFormJson(jsonPath, strict)
    ' Implementación básica de validación
    Dim file, content
    Set file = objFSO.OpenTextFile(jsonPath, 1)
    content = file.ReadAll
    file.Close
    
    ' Validaciones básicas
    If InStr(content, "schemaVersion") = 0 Then
        WScript.Echo "Error: Falta campo requerido 'schemaVersion'"
        ValidateFormJson = False
        Exit Function
    End If
    
    If InStr(content, "properties") = 0 Then
        WScript.Echo "Error: Falta campo requerido 'properties'"
        ValidateFormJson = False
        Exit Function
    End If
    
    If InStr(content, "sections") = 0 Then
        WScript.Echo "Error: Falta campo requerido 'sections'"
        ValidateFormJson = False
        Exit Function
    End If
    
    ValidateFormJson = True
End Function

' ===== FUNCIONES AUXILIARES PARA IMPORTACIÓN =====

Sub ApplyFormProperties(form, properties)
    ' Aplicar propiedades del formulario - implementación básica
    WScript.Echo "Advertencia: Aplicación de propiedades no implementada completamente"
    ' TODO: Implementar aplicación de propiedades cuando se necesite
End Sub

Sub CreateFormSections(form, sections)
    ' Crear y configurar secciones del formulario
    Dim sectionName, sectionData
    For Each sectionName In sections.Keys
        Set sectionData = sections(sectionName)
        
        ' Obtener referencia a la sección
        Dim section
        Select Case LCase(sectionName)
            Case "detail", "detalle"
                Set section = form.Section(acDetail)
            Case "header", "encabezado"
                Set section = form.Section(acHeader)
            Case "footer", "pie"
                Set section = form.Section(acFooter)
        End Select
        
        ' Aplicar propiedades de la sección
        If Not section Is Nothing And sectionData.Exists("properties") Then
            Call ApplySectionProperties(section, sectionData("properties"))
        End If
    Next
End Sub

Sub ApplySectionProperties(section, properties)
    ' Aplicar propiedades a una sección específica
    Dim key, value, normalizedKey
    For Each key In properties.Keys
        normalizedKey = MapPropKey(key)
        value = properties(key)
        
        On Error Resume Next
        section.Properties(normalizedKey) = value
        If Err.Number <> 0 Then
            WScript.Echo "Advertencia: No se pudo aplicar propiedad de sección '" & normalizedKey & "' = '" & value & "'"
            Err.Clear
        End If
        On Error GoTo 0
    Next
End Sub

Sub CreateFormControls(objAccess, form, controls, strict)
    ' Crear controles del formulario - implementación básica
    If strict Then
        WScript.Echo "Advertencia: Creación de controles no implementada completamente"
    End If
    ' TODO: Implementar creación de controles cuando se necesite
End Sub

Sub CreateSingleControl(objAccess, form, controlName, controlData, strict)
    ' Crear un control individual
    Dim controlType, acType, acSection
    Dim left, top, width, height, parent, controlSource
    
    ' Obtener tipo de control y convertir a constante Access
    If controlData.Exists("type") Then
        controlType = controlData("type")
        acType = MapControlType(controlType)
        If acType = -1 Then
            WScript.Echo "Advertencia: Tipo de control desconocido: " & controlType
            Exit Sub
        End If
    Else
        WScript.Echo "Error: Control '" & controlName & "' no tiene tipo especificado"
        Exit Sub
    End If
    
    ' Determinar sección (por defecto Detail)
    acSection = acDetail
    If controlData.Exists("section") Then
        Select Case LCase(controlData("section"))
            Case "header", "encabezado": acSection = acHeader
            Case "footer", "pie": acSection = acFooter
            Case Else: acSection = acDetail
        End Select
    End If
    
    ' Obtener propiedades de posición y tamaño
    left = 0: top = 0: width = 1440: height = 240
    If controlData.Exists("properties") Then
        Dim props: Set props = controlData("properties")
        If props.Exists("Left") Then left = props("Left")
        If props.Exists("Top") Then top = props("Top")
        If props.Exists("Width") Then width = props("Width")
        If props.Exists("Height") Then height = props("Height")
    End If
    
    ' Obtener parent y controlSource si existen
    parent = ""
    controlSource = ""
    If controlData.Exists("properties") Then
        If controlData("properties").Exists("Parent") Then parent = controlData("properties")("Parent")
        If controlData("properties").Exists("ControlSource") Then controlSource = controlData("properties")("ControlSource")
    End If
    
    ' Crear el control
    Dim newControl
    On Error Resume Next
    Set newControl = objAccess.Application.CreateControl(form.Name, acType, acSection, parent, controlSource, left, top, width, height)
    If Err.Number <> 0 Then
        WScript.Echo "Error creando control '" & controlName & "': " & Err.Description
        Err.Clear
        On Error GoTo 0
        Exit Sub
    End If
    On Error GoTo 0
    
    ' Establecer el nombre del control
    newControl.Name = controlName
    
    ' Aplicar propiedades restantes
    If controlData.Exists("properties") Then
        Call ApplyControlProperties(newControl, controlData("properties"))
    End If
End Sub

Sub ApplyControlProperties(control, properties)
    ' Aplicar propiedades a un control
    Dim key, value, normalizedKey
    For Each key In properties.Keys
        ' Saltar propiedades ya aplicadas durante la creación
        If LCase(key) = "left" Or LCase(key) = "top" Or LCase(key) = "width" Or LCase(key) = "height" Or LCase(key) = "parent" Or LCase(key) = "controlsource" Then
            ' Skip
        Else
            normalizedKey = MapPropKey(key)
            value = properties(key)
            
            ' Normalizar tokens de enumeración si es necesario
            If IsEnumProperty(normalizedKey) Then
                value = NormalizeEnumToken(CStr(value))
            End If
            
            On Error Resume Next
            control.Properties(normalizedKey) = value
            If Err.Number <> 0 Then
                WScript.Echo "Advertencia: No se pudo aplicar propiedad '" & normalizedKey & "' = '" & value & "' al control '" & control.Name & "'"
                Err.Clear
            End If
            On Error GoTo 0
        End If
    Next
End Sub

Sub ApplyFormEvents(form, handlers, strict)
    ' Aplicar eventos del formulario - implementación básica
    If strict Then
        WScript.Echo "Advertencia: Aplicación de eventos no implementada completamente"
    End If
    ' TODO: Implementar aplicación de eventos cuando se necesite
End Sub

Function IsEnumProperty(propName)
    ' Determinar si una propiedad es de tipo enumeración
    Select Case LCase(propName)
        Case "textalign", "alignment", "backstyle", "borderstyle", "specialeffect"
            IsEnumProperty = True
        Case Else
            IsEnumProperty = False
    End Select
End Function

Function MapEventToProperty(eventName)
    ' Mapear nombres de eventos a propiedades de Access
    Select Case LCase(eventName)
        Case "click", "onclick": MapEventToProperty = "OnClick"
        Case "load", "onload": MapEventToProperty = "OnLoad"
        Case "unload", "onunload": MapEventToProperty = "OnUnload"
        Case "current", "oncurrent": MapEventToProperty = "OnCurrent"
        Case "beforeupdate", "onbeforeupdate": MapEventToProperty = "OnBeforeUpdate"
        Case "afterupdate", "onafterupdate": MapEventToProperty = "OnAfterUpdate"
        Case Else: MapEventToProperty = ""
    End Select
End Function

Sub ExecuteRoundtripFlow(dbPath, formName, tempDir, password)
    Dim preJsonPath, postJsonPath
    preJsonPath = tempDir & "\" & formName & ".json"
    postJsonPath = tempDir & "\" & formName & ".post.json"
    
    ' Paso 1: Exportar formulario original
    Dim objAccess
    Set objAccess = OpenAccessQuiet(dbPath, password)
    If objAccess Is Nothing Then
        WScript.Echo "Error: No se pudo abrir la base de datos"
        WScript.Quit 1
    End If
    
    Call ExportFormToJson(objAccess, formName, preJsonPath, False, "")
    WScript.Echo "Paso 1: Exportado a " & preJsonPath
    
    ' Paso 2: Reimportar sobre el mismo formulario
    Call ImportFormFromJson(objAccess, preJsonPath, formName, True, False)
    WScript.Echo "Paso 2: Reimportado desde " & preJsonPath
    
    ' Paso 3: Exportar nuevamente
    Call ExportFormToJson(objAccess, formName, postJsonPath, False, "")
    WScript.Echo "Paso 3: Re-exportado a " & postJsonPath
    
    Call CloseAccessQuiet(objAccess)
    
    ' Paso 4: Comparar diferencias (implementación básica)
    If DiffJsonSemantico(preJsonPath, postJsonPath) Then
        WScript.Echo "Roundtrip exitoso: No hay diferencias"
        WScript.Quit 0
    Else
        WScript.Echo "Roundtrip fallido: Se encontraron diferencias"
        WScript.Quit 1
    End If
End Sub

Function DiffJsonSemantico(file1, file2)
    ' Comparación semántica de archivos JSON
    On Error Resume Next
    
    Dim content1, content2
    Dim f1, f2
    
    Set f1 = objFSO.OpenTextFile(file1, 1)
    content1 = f1.ReadAll
    f1.Close
    
    Set f2 = objFSO.OpenTextFile(file2, 1)
    content2 = f2.ReadAll
    f2.Close
    
    ' Normalizar contenido para comparación semántica
    content1 = NormalizeJsonForComparison(content1)
    content2 = NormalizeJsonForComparison(content2)
    
    DiffJsonSemantico = (content1 = content2)
    
    On Error GoTo 0
End Function

' ===== FUNCIONES AUXILIARES JSON =====

Function NormalizeJsonForComparison(jsonText)
    ' Normaliza JSON removiendo metadata variable para comparación
    Dim result
    result = jsonText
    
    ' Remover timestamps variables y campos volátiles
    Dim regEx
    Set regEx = CreateObject("VBScript.RegExp")
    regEx.Global = True
    
    ' Remover generatedAtUTC
    regEx.Pattern = """generatedAtUTC""\s*:\s*""[^""]+"",?"
    result = regEx.Replace(result, "")
    
    ' Remover GUIDs internos volátiles
    regEx.Pattern = """guid""\s*:\s*""[^""]+"",?"
    result = regEx.Replace(result, "")
    
    ' Remover LayoutId volátiles
    regEx.Pattern = """layoutId""\s*:\s*[^,}]+,?"
    result = regEx.Replace(result, "")
    
    ' Remover timestamps de creación/modificación
    regEx.Pattern = """(created|modified|lastModified)At(UTC)?""\s*:\s*""[^""]+"",?"
    result = regEx.Replace(result, "")
    
    ' Remover metadatos internos de Access
    regEx.Pattern = """(internalId|objectId|moduleId)""\s*:\s*[^,}]+,?"
    result = regEx.Replace(result, "")
    
    ' Normalizar espacios y comas extra
    regEx.Pattern = ",\s*,"
    result = regEx.Replace(result, ",")
    
    regEx.Pattern = ",\s*}"
    result = regEx.Replace(result, "}")
    
    regEx.Pattern = ",\s*]"
    result = regEx.Replace(result, "]")
    
    ' Remover espacios extra y normalizar
    regEx.Pattern = "\s+"
    result = regEx.Replace(result, " ")
    
    ' Normalizar orden de claves (implementación básica)
    ' Para una comparación más robusta, aquí se podría implementar
    ' un parser JSON completo y reordenar las claves alfabéticamente
    
    NormalizeJsonForComparison = Trim(result)
End Function

' ===== FUNCIONES DE NORMALIZACIÓN ES/EN =====

Function MapPropKey(key)
    ' Mapea claves de propiedades de español a inglés
    Select Case LCase(Trim(key))
        ' Propiedades básicas
        Case "ancho": MapPropKey = "width"
        Case "alto": MapPropKey = "height"
        Case "izquierda": MapPropKey = "left"
        Case "arriba": MapPropKey = "top"
        Case "etiqueta": MapPropKey = "caption"
        Case "texto": MapPropKey = "caption"
        Case "origencontrol": MapPropKey = "controlSource"
        Case "origen": MapPropKey = "controlSource"
        Case "fuente": MapPropKey = "fontName"
        Case "tamañofuente": MapPropKey = "fontSize"
        Case "negrita": MapPropKey = "fontBold"
        Case "cursiva": MapPropKey = "fontItalic"
        Case "subrayado": MapPropKey = "fontUnderline"
        Case "colordefondo": MapPropKey = "backColor"
        Case "colortexto": MapPropKey = "foreColor"
        Case "visible": MapPropKey = "visible"
        Case "habilitado": MapPropKey = "enabled"
        Case "bloqueado": MapPropKey = "locked"
        Case "alineaciontexto": MapPropKey = "textAlign"
        Case "borde": MapPropKey = "borderStyle"
        Case "efectoespecial": MapPropKey = "specialEffect"
        Case "imagen": MapPropKey = "picture"
        Case "tipoimagen": MapPropKey = "pictureType"
        Case "alineacionimagen": MapPropKey = "pictureAlignment"
        Case "modoajuste": MapPropKey = "sizeMode"
        Case "formato": MapPropKey = "format"
        Case "mascaraentrada": MapPropKey = "inputMask"
        Case "valorpredeterminado": MapPropKey = "defaultValue"
        Case "reglavalidacion": MapPropKey = "validationRule"
        Case "textovalidacion": MapPropKey = "validationText"
        Case "requerido": MapPropKey = "required"
        Case "permitirlongitudcero": MapPropKey = "allowZeroLength"
        Case "indexado": MapPropKey = "indexed"
        Case "unicodcompresion": MapPropKey = "unicodeCompression"
        Case "ime": MapPropKey = "imeMode"
        Case "etiquetainteligente": MapPropKey = "smartTags"
        Case "ayudacontextual": MapPropKey = "helpContextId"
        Case "textoayuda": MapPropKey = "statusBarText"
        Case "sugerencia": MapPropKey = "controlTipText"
        Case "ordendetabulacion": MapPropKey = "tabIndex"
        Case "detenerdetabulacion": MapPropKey = "tabStop"
        Case "teclaacceso": MapPropKey = "shortcutMenuBar"
        Case "menucontextual": MapPropKey = "shortcutMenuBar"
        Case "barramenu": MapPropKey = "menuBar"
        Case "barraherramientas": MapPropKey = "toolbar"
        Case "filtro": MapPropKey = "filter"
        Case "ordenar": MapPropKey = "orderBy"
        Case "permitirfiltros": MapPropKey = "allowFilters"
        Case "permitiredicion": MapPropKey = "allowEdits"
        Case "permitiragregar": MapPropKey = "allowAdditions"
        Case "permitireliminar": MapPropKey = "allowDeletions"
        Case "permitirdiseño": MapPropKey = "allowDesignChanges"
        Case "entradadatos": MapPropKey = "dataEntry"
        Case "conjuntoregistros": MapPropKey = "recordset"
        Case "tipoconjuntoregistros": MapPropKey = "recordsetType"
        Case "origenregistro": MapPropKey = "recordSource"
        Case "bloqueosregistros": MapPropKey = "recordLocks"
        Case "maxregistros": MapPropKey = "maxRecords"
        Case "cargarporeventos": MapPropKey = "loadOnOpen"
        Case "cerraralsalir": MapPropKey = "closeButton"
        Case "botonesbarra": MapPropKey = "recordSelectors"
        Case "selectoresregistro": MapPropKey = "recordSelectors"
        Case "barranavegacion": MapPropKey = "navigationButtons"
        Case "lineasdivision": MapPropKey = "dividerLines"
        Case "autocentrar": MapPropKey = "autoCenter"
        Case "autoresize": MapPropKey = "autoResize"
        Case "ajustarventana": MapPropKey = "fitToScreen"
        Case "modal": MapPropKey = "modal"
        Case "popup": MapPropKey = "popup"
        Case "ciclotabulacion": MapPropKey = "cycle"
        Case "vistaformulario": MapPropKey = "defaultView"
        Case "vistapredeterminada": MapPropKey = "defaultView"
        Case "permitirvistahojadatos": MapPropKey = "allowDatasheetView"
        Case "permitirvistapivot": MapPropKey = "allowPivotTableView"
        Case "permitirvistatabladinamica": MapPropKey = "allowPivotChartView"
        Case "permitirvistaformulario": MapPropKey = "allowFormView"
        Case "permitirlayout": MapPropKey = "allowLayoutView"
        Case "subdatasheets": MapPropKey = "subdatasheetName"
        Case "expandirsubdatasheets": MapPropKey = "subdatasheetExpanded"
        Case "alturasubdatasheets": MapPropKey = "subdatasheetHeight"
        Case "orientacionformulario": MapPropKey = "orientation"
        Case "orientacionformulariodividido": MapPropKey = "splitFormOrientation"
        Case "tamañoformulariodividido": MapPropKey = "splitFormSize"
        Case "impresionformulariodividido": MapPropKey = "splitFormPrinting"
        Case "barradesplazamiento": MapPropKey = "splitFormSplitterBar"
        Case "datasheet": MapPropKey = "splitFormDatasheet"
        Case "formulariodividido": MapPropKey = "splitFormOrientation"
        Case Else
            ' Si no hay mapeo, devolver la clave original
            MapPropKey = key
    End Select
End Function

Function NormalizeEnumToken(token)
    ' Normaliza tokens de enumeraciones de español a inglés
    Select Case LCase(Trim(token))
        ' Alineación de texto
        Case "izquierda", "left": NormalizeEnumToken = "left"
        Case "centro", "centrado", "center": NormalizeEnumToken = "center"
        Case "derecha", "right": NormalizeEnumToken = "right"
        Case "justificado", "justify": NormalizeEnumToken = "justify"
        Case "distribuir", "distribute": NormalizeEnumToken = "distribute"
        
        ' Tipos de borde
        Case "transparente", "transparent": NormalizeEnumToken = "transparent"
        Case "solido", "solid": NormalizeEnumToken = "solid"
        Case "punteado", "dashes": NormalizeEnumToken = "dashes"
        Case "puntos", "dots": NormalizeEnumToken = "dots"
        Case "doble", "double": NormalizeEnumToken = "double"
        
        ' Efectos especiales
        Case "plano", "flat": NormalizeEnumToken = "flat"
        Case "elevado", "raised": NormalizeEnumToken = "raised"
        Case "hundido", "sunken": NormalizeEnumToken = "sunken"
        Case "grabado", "etched": NormalizeEnumToken = "etched"
        Case "sombra", "shadowed": NormalizeEnumToken = "shadowed"
        Case "cincelado", "chiseled": NormalizeEnumToken = "chiseled"
        
        ' Tipos de vista
        Case "formulario", "form": NormalizeEnumToken = "form"
        Case "continuo", "continuous": NormalizeEnumToken = "continuous"
        Case "hojadatos", "datasheet": NormalizeEnumToken = "datasheet"
        Case "tabladinamica", "pivottable": NormalizeEnumToken = "pivottable"
        Case "graficopivot", "pivotchart": NormalizeEnumToken = "pivotchart"
        
        ' Orientación
        Case "horizontal": NormalizeEnumToken = "horizontal"
        Case "vertical": NormalizeEnumToken = "vertical"
        
        ' Orientación de formulario dividido
        Case "arriba", "top": NormalizeEnumToken = "top"
        Case "abajo", "bottom": NormalizeEnumToken = "bottom"
        
        ' Tipos de conjunto de registros
        Case "dynaset": NormalizeEnumToken = "dynaset"
        Case "snapshot": NormalizeEnumToken = "snapshot"
        
        ' Ciclo de tabulación
        Case "todosregistros", "allrecords": NormalizeEnumToken = "allrecords"
        Case "registroactual", "currentrecord": NormalizeEnumToken = "currentrecord"
        Case "paginaactual", "currentpage": NormalizeEnumToken = "currentpage"
        
        ' Modo de ajuste de imagen
        Case "recortar", "clip": NormalizeEnumToken = "clip"
        Case "estirar", "stretch": NormalizeEnumToken = "stretch"
        Case "zoom": NormalizeEnumToken = "zoom"
        
        ' Alineación de imagen
        Case "esquinasuperioriz", "topleft": NormalizeEnumToken = "topleft"
        Case "arribacentro", "topcenter": NormalizeEnumToken = "topcenter"
        Case "esquinasuperiorder", "topright": NormalizeEnumToken = "topright"
        Case "centroizquierda", "centerleft": NormalizeEnumToken = "centerleft"
        Case "centrocentro", "centercenter": NormalizeEnumToken = "centercenter"
        Case "centroderecha", "centerright": NormalizeEnumToken = "centerright"
        Case "esquinainferioriz", "bottomleft": NormalizeEnumToken = "bottomleft"
        Case "abajocentro", "bottomcenter": NormalizeEnumToken = "bottomcenter"
        Case "esquinainferiorder", "bottomright": NormalizeEnumToken = "bottomright"
        
        ' Valores booleanos
        Case "verdadero", "true", "si", "yes": NormalizeEnumToken = "true"
        Case "falso", "false", "no": NormalizeEnumToken = "false"
        
        Case Else
            ' Si no hay mapeo, devolver el token original
            NormalizeEnumToken = token
    End Select
End Function

Function MapControlType(controlType)
    ' Mapea tipos de control de español a inglés
    Select Case LCase(Trim(controlType))
        Case "etiqueta", "label": MapControlType = "Label"
        Case "cuadrodetexto", "textbox": MapControlType = "TextBox"
        Case "boton", "commandbutton": MapControlType = "CommandButton"
        Case "casilladeseleccion", "checkbox": MapControlType = "CheckBox"
        Case "botonopcion", "optionbutton": MapControlType = "OptionButton"
        Case "cuadrocombo", "combobox": MapControlType = "ComboBox"
        Case "cuadrolista", "listbox": MapControlType = "ListBox"
        Case "subformulario", "subform": MapControlType = "SubForm"
        Case "imagen", "image": MapControlType = "Image"
        Case "marcoobjetono", "unboundobjectframe": MapControlType = "UnboundObjectFrame"
        Case "marcoobjetoenlazado", "boundobjectframe": MapControlType = "BoundObjectFrame"
        Case "saltolinea", "pagebreak": MapControlType = "PageBreak"
        Case "separador", "line": MapControlType = "Line"
        Case "rectangulo", "rectangle": MapControlType = "Rectangle"
        Case "grupoopciones", "optiongroup": MapControlType = "OptionGroup"
        Case "pestañas", "tabcontrol": MapControlType = "TabControl"
        Case "activex", "customcontrol": MapControlType = "CustomControl"
        Case Else
            ' Si no hay mapeo, devolver el tipo original
            MapControlType = controlType
    End Select
End Function

' ===== INFRAESTRUCTURA JSON CENTRALIZADA =====

Class JsonWriter
    Private jsonContent
    Private objectStack
    Private arrayStack
    Private currentState
    Private needsComma
    
    Private Sub Class_Initialize()
        jsonContent = ""
        Set objectStack = CreateList()
        Set arrayStack = CreateList()
        currentState = "root"
        needsComma = False
    End Sub
    
    Public Sub StartObject()
        If needsComma Then
            jsonContent = jsonContent & ","
        End If
        jsonContent = jsonContent & "{"
        ' Verificar si objectStack es ArrayList o Dictionary
        If TypeName(objectStack) = "ArrayList" Then
            objectStack.Add currentState
        Else
            ' Es Dictionary, usar como lista con índices numéricos
            objectStack.Add objectStack.Count, currentState
        End If
        currentState = "object"
        needsComma = False
    End Sub
    
    Public Sub EndObject()
        jsonContent = jsonContent & "}"
        If objectStack.Count > 0 Then
            ' Verificar si objectStack es ArrayList o Dictionary
            If TypeName(objectStack) = "ArrayList" Then
                currentState = objectStack(objectStack.Count - 1)
                objectStack.RemoveAt objectStack.Count - 1
            Else
                ' Es Dictionary, usar como lista con índices numéricos
                currentState = objectStack(objectStack.Count - 1)
                objectStack.Remove objectStack.Count - 1
            End If
            needsComma = True
        End If
    End Sub
    
    Public Sub StartArray()
        If needsComma Then
            jsonContent = jsonContent & ","
        End If
        jsonContent = jsonContent & "["
        ' Verificar si arrayStack es ArrayList o Dictionary
        If TypeName(arrayStack) = "ArrayList" Then
            arrayStack.Add currentState
        Else
            ' Es Dictionary, usar como lista con índices numéricos
            arrayStack.Add arrayStack.Count, currentState
        End If
        currentState = "array"
        needsComma = False
    End Sub
    
    Public Sub EndArray()
        jsonContent = jsonContent & "]"
        If arrayStack.Count > 0 Then
            ' Verificar si arrayStack es ArrayList o Dictionary
            If TypeName(arrayStack) = "ArrayList" Then
                currentState = arrayStack(arrayStack.Count - 1)
                arrayStack.RemoveAt arrayStack.Count - 1
            Else
                ' Es Dictionary, usar como lista con índices numéricos
                currentState = arrayStack(arrayStack.Count - 1)
                arrayStack.Remove arrayStack.Count - 1
            End If
            needsComma = True
        End If
    End Sub
    
    Public Sub AddProperty(key, value)
        If needsComma Then
            jsonContent = jsonContent & ","
        End If
        jsonContent = jsonContent & """" & EscapeString(CStr(key)) & """:" & FormatValue(value)
        needsComma = True
    End Sub
    
    Public Sub StartObjectProperty(key)
        If needsComma Then
            jsonContent = jsonContent & ","
        End If
        jsonContent = jsonContent & """" & EscapeString(CStr(key)) & """:{"
        ' Verificar si objectStack es ArrayList o Dictionary
        If TypeName(objectStack) = "ArrayList" Then
            objectStack.Add currentState
        Else
            ' Es Dictionary, usar como lista con índices numéricos
            objectStack.Add objectStack.Count, currentState
        End If
        currentState = "object"
        needsComma = False
    End Sub
    
    Public Sub StartArrayProperty(key)
        If needsComma Then
            jsonContent = jsonContent & ","
        End If
        jsonContent = jsonContent & """" & EscapeString(CStr(key)) & """:["
        ' Verificar si arrayStack es ArrayList o Dictionary
        If TypeName(arrayStack) = "ArrayList" Then
            arrayStack.Add currentState
        Else
            ' Es Dictionary, usar como lista con índices numéricos
            arrayStack.Add arrayStack.Count, currentState
        End If
        currentState = "array"
        needsComma = False
    End Sub
    
    Public Sub AddValue(value)
        If needsComma Then
            jsonContent = jsonContent & ","
        End If
        jsonContent = jsonContent & FormatValue(value)
        needsComma = True
    End Sub
    
    Public Function GetJson()
        GetJson = jsonContent
    End Function
    
    Private Function FormatValue(value)
        If IsNull(value) Then
            FormatValue = "null"
        ElseIf VarType(value) = vbBoolean Then
            If value Then
                FormatValue = "true"
            Else
                FormatValue = "false"
            End If
        ElseIf IsNumeric(value) Then
            FormatValue = CStr(value)
        ElseIf VarType(value) = vbString Then
            FormatValue = """" & EscapeString(CStr(value)) & """"
        Else
            FormatValue = """" & EscapeString(CStr(value)) & """"
        End If
    End Function
    
    Private Function EscapeString(str)
        Dim result, i, char
        result = ""
        For i = 1 To Len(str)
            char = Mid(str, i, 1)
            Select Case char
                Case Chr(34) ' "
                    result = result & "\"""
                Case Chr(92) ' backslash
                    result = result & "\\"
                Case Chr(8)  ' \b
                    result = result & "\b"
                Case Chr(12) ' \f
                    result = result & "\f"
                Case Chr(10) ' \n
                    result = result & "\n"
                Case Chr(13) ' \r
                    result = result & "\r"
                Case Chr(9)  ' \t
                    result = result & "\t"
                Case Else
                    If Asc(char) < 32 Then
                        result = result & "\u" & Right("0000" & Hex(Asc(char)), 4)
                    Else
                        result = result & char
                    End If
            End Select
        Next
        EscapeString = result
    End Function
    
    ' Métodos de compatibilidad con la implementación anterior
    Public Sub WriteProperty(key, value)
        ' Método de compatibilidad que usa AddProperty
        AddProperty key, value
    End Sub
    
    Public Function Stringify(value)
        If IsNull(value) Then
            Stringify = "null"
        ElseIf VarType(value) = vbBoolean Then
            If value Then
                Stringify = "true"
            Else
                Stringify = "false"
            End If
        ElseIf IsNumeric(value) Then
            Stringify = CStr(value)
        ElseIf VarType(value) = vbString Then
            Stringify = """" & EscapeString(CStr(value)) & """"
        Else
            Stringify = """" & EscapeString(CStr(value)) & """"
        End If
    End Function
End Class

' ===== COMANDO LIST-FORMS ACTUALIZADO =====

Sub ListFormsCommand()
    Dim password, bJsonOutput
    Dim i, arg
    Dim formsList, formCount
    Dim objAccess, formName
    
    ' Inicializar variables
    password = gPassword
    bJsonOutput = False
    
    ' Procesar argumentos especificos de list-forms
    For i = 1 To objArgs.Count - 1
        arg = objArgs(i)
        If Left(arg, 2) = "--" Then
            If arg = "--password" And i < objArgs.Count - 1 Then
                password = objArgs(i + 1)
            ElseIf arg = "--json" Then
                bJsonOutput = True
            ElseIf arg = "--help" Then
                Call ShowListFormsHelp()
                WScript.Quit 0
            End If
        End If
    Next
    
    ' Abrir Access con OpenAccessQuiet
    Set objAccess = OpenAccessQuiet(strAccessPath, password)
    If objAccess Is Nothing Then
        WScript.Echo "Error: No se pudo abrir la base de datos"
        WScript.Quit 1
    End If
    
    ' Contar formularios primero
    formCount = 0
    For Each formName In objAccess.CurrentProject.AllForms
        formCount = formCount + 1
    Next
    
    ' Redimensionar array y llenar
    Dim formsArray()
    If formCount > 0 Then
        ReDim formsArray(formCount - 1)
        Dim formIndex
        formIndex = 0
        For Each formName In objAccess.CurrentProject.AllForms
            formsArray(formIndex) = formName.Name
            formIndex = formIndex + 1
        Next
    Else
        ' Si no hay formularios, crear array vacío
        ReDim formsArray(-1)
    End If
    
    ' Cerrar Access
    Call CloseAccessQuiet(objAccess)
    
    ' Generar salida
    If bJsonOutput Then
        ' Salida JSON
        Dim jsonOutput
        jsonOutput = "["
        If formCount > 0 Then
            Dim i_form
            For i_form = 0 To UBound(formsArray)
                If i_form > 0 Then jsonOutput = jsonOutput & ","
                jsonOutput = jsonOutput & """" & formsArray(i_form) & """"
            Next
        End If
        jsonOutput = jsonOutput & "]"
        WScript.Echo jsonOutput
    Else
        ' Salida texto
        If formCount = 0 Then
            WScript.Echo "No se encontraron formularios en la base de datos."
        Else
            WScript.Echo "Formularios encontrados (" & formCount & "):"
            For i_form = 0 To UBound(formsArray)
                WScript.Echo "  " & formsArray(i_form)
            Next
        End If
    End If
End Sub

Sub ShowListFormsHelp()
    WScript.Echo "=== LIST-FORMS - Listar formularios de la base de datos ==="
    WScript.Echo "Uso: cscript condor_cli.vbs list-forms [db_path] [opciones]"
    WScript.Echo ""
    WScript.Echo "PARAMETROS:"
    WScript.Echo "  [db_path]         - Ruta de la base de datos (opcional si se resuelve automáticamente)"
    WScript.Echo ""
    WScript.Echo "OPCIONES:"
    WScript.Echo "  --password <pwd>  - Contraseña de la base de datos"
    WScript.Echo "  --json            - Salida en formato JSON"
    WScript.Echo ""
    WScript.Echo "EJEMPLOS:"
    WScript.Echo "  cscript condor_cli.vbs list-forms"
    WScript.Echo "  cscript condor_cli.vbs list-forms --json"
    WScript.Echo "  cscript condor_cli.vbs list-forms --db ""C:\MiDB.accdb"" --password 1234"
End Sub

' ===== FUNCIONES AUXILIARES PARA VALIDACION JSON =====

' ===== FUNCIONES DE BUNDLE =====

Function GetFunctionalityFiles(strFunctionality)
    Dim arrFiles
    
    Select Case LCase(strFunctionality)
        Case "auth", "autenticacion", "authentication"
            ' Seccion 3.1 - Autenticacion + Dependencias
            arrFiles = Array("IAuthService.cls", "CAuthService.cls", "CMockAuthService.cls", _
                           "IAuthRepository.cls", "CAuthRepository.cls", "CMockAuthRepository.cls", _
                           "EAuthData.cls", "modAuthFactory.bas", "TestAuthService.bas", _
                           "TIAuthRepository.bas", _
                           "IConfig.cls", "IErrorHandlerService.cls", "modEnumeraciones.bas")
        
        Case "document", "documentos", "documents"
            ' Seccion 3.2 - Gestion de Documentos + Dependencias
            arrFiles = Array("IDocumentService.cls", "CDocumentService.cls", "CMockDocumentService.cls", _
                           "IWordManager.cls", "CWordManager.cls", "CMockWordManager.cls", _
                           "IMapeoRepository.cls", "CMapeoRepository.cls", "CMockMapeoRepository.cls", _
                           "EMapeo.cls", "modDocumentServiceFactory.bas", _
                           "TIDocumentService.bas", _
                           "ISolicitudService.cls", "CSolicitudService.cls", "modSolicitudServiceFactory.bas", _
                           "IOperationLogger.cls", "IConfig.cls", "IErrorHandlerService.cls", "IFileSystem.cls", _
                           "modWordManagerFactory.bas", "modRepositoryFactory.bas", "modErrorHandlerFactory.bas")
        
        Case "expediente", "expedientes"
            ' Seccion 3.3 - Gestion de Expedientes + Dependencias
            arrFiles = Array("IExpedienteService.cls", "CExpedienteService.cls", "CMockExpedienteService.cls", _
                           "IExpedienteRepository.cls", "CExpedienteRepository.cls", "CMockExpedienteRepository.cls", _
                           "EExpediente.cls", "modExpedienteServiceFactory.bas", "TestCExpedienteService.bas", _
                           "TIExpedienteRepository.bas", "modRepositoryFactory.bas", _
                           "IConfig.cls", "IOperationLogger.cls", "IErrorHandlerService.cls")
        
        Case "solicitud", "solicitudes"
            ' Seccion 3.4 - Gestion de Solicitudes + Dependencias
            arrFiles = Array("ISolicitudService.cls", "CSolicitudService.cls", "CMockSolicitudService.cls", _
                           "ISolicitudRepository.cls", "CSolicitudRepository.cls", "CMockSolicitudRepository.cls", _
                           "ESolicitud.cls", "EDatosPc.cls", "EDatosCdCa.cls", "EDatosCdCaSub.cls", _
                           "modSolicitudServiceFactory.bas", "TestSolicitudService.bas", _
                           "TISolicitudRepository.bas", _
                           "IAuthService.cls", "modAuthFactory.bas", _
                           "IOperationLogger.cls", "IErrorHandlerService.cls", "IConfig.cls")
        
        Case "workflow", "flujo"
            ' Seccion 3.5 - Gestion de Workflow + Dependencias
            arrFiles = Array("IWorkflowService.cls", "CWorkflowService.cls", "CMockWorkflowService.cls", _
                           "IWorkflowRepository.cls", "CWorkflowRepository.cls", "CMockWorkflowRepository.cls", _
                           "modWorkflowServiceFactory.bas", "TestWorkflowService.bas", _
                           "TIWorkflowRepository.bas", _
                           "IOperationLogger.cls", "IConfig.cls", "IErrorHandlerService.cls")
        
        Case "mapeo", "mapping"
            ' Seccion 3.6 - Gestion de Mapeos + Dependencias
            arrFiles = Array("IMapeoRepository.cls", "CMapeoRepository.cls", "CMockMapeoRepository.cls", _
                           "EMapeo.cls", "TIMapeoRepository.bas", _
                           "IConfig.cls", "IErrorHandlerService.cls")
        
        Case "notification", "notificacion"
            ' Seccion 3.7 - Gestion de Notificaciones + Dependencias
            arrFiles = Array("INotificationService.cls", "CNotificationService.cls", "CMockNotificationService.cls", _
                           "INotificationRepository.cls", "CNotificationRepository.cls", "CMockNotificationRepository.cls", _
                           "modNotificationServiceFactory.bas", "TINotificationService.bas", _
                           "IOperationLogger.cls", "IErrorHandlerService.cls", "IConfig.cls")
        
        Case "operation", "operacion", "logging"
            ' Seccion 3.8 - Gestion de Operaciones y Logging + Dependencias
            arrFiles = Array("IOperationLogger.cls", "COperationLogger.cls", "CMockOperationLogger.cls", _
                           "IOperationRepository.cls", "COperationRepository.cls", "CMockOperationRepository.cls", _
                           "EOperationLog.cls", "modOperationLoggerFactory.bas", "TestOperationLogger.bas", _
                           "TIOperationRepository.bas", _
                           "IErrorHandlerService.cls", "IConfig.cls")
        
        Case "config", "configuracion"
            ' Seccion 4 - Configuracion + Dependencias
            arrFiles = Array("IConfig.cls", "CConfig.cls", "CMockConfig.cls", "modConfigFactory.bas", _
                           "TestCConfig.bas")
        
        Case "filesystem", "archivos"
            ' Seccion 5 - Sistema de Archivos + Dependencias
            arrFiles = Array("IFileSystem.cls", "CFileSystem.cls", "CMockFileSystem.cls", _
                           "modFileSystemFactory.bas", "TIFileSystem.bas", _
                           "IErrorHandlerService.cls")
        
        Case "word"
            ' Seccion 6 - Gestion de Word + Dependencias
            arrFiles = Array("IWordManager.cls", "CWordManager.cls", "CMockWordManager.cls", _
                           "modWordManagerFactory.bas", "TIWordManager.bas", _
                           "IFileSystem.cls", "IErrorHandlerService.cls")
        
        Case "error", "errores", "errors"
            ' Seccion 7 - Gestion de Errores + Dependencias
            arrFiles = Array("IErrorHandlerService.cls", "CErrorHandlerService.cls", "CMockErrorHandlerService.cls", _
                           "modErrorHandlerFactory.bas", "TestErrorHandlerService.bas", _
                           "IConfig.cls", "IFileSystem.cls")
        
        Case "testframework", "testing", "framework"
            ' Seccion 8 - Framework de Testing + Dependencias
            arrFiles = Array("ITestReporter.cls", "CTestResult.cls", "CTestSuiteResult.cls", "CTestReporter.cls", _
                           "modTestRunner.bas", "modTestUtils.bas", "modAssert.bas", _
                           "TestModAssert.bas", "IFileSystem.cls", "IConfig.cls", _
                           "IErrorHandlerService.cls")
        
        Case "app", "aplicacion", "application"
            ' Seccion 9 - Gestion de Aplicacion + Dependencias
            arrFiles = Array("IAppManager.cls", "CAppManager.cls", "CMockAppManager.cls", _
                           "ModAppManagerFactory.bas", "TestAppManager.bas", "IAuthService.cls", _
                           "IConfig.cls", "IErrorHandlerService.cls")
        
        Case "models", "modelos", "datos"
            ' Seccion 10 - Modelos de Datos
            arrFiles = Array("EUsuario.cls", "ESolicitud.cls", "EExpediente.cls", "EDatosPc.cls", _
                           "EDatosCdCa.cls", "EDatosCdCaSub.cls", "EEstado.cls", "ETransicion.cls", _
                           "EMapeo.cls", "EAdjuntos.cls", "ELogCambios.cls", "ELogErrores.cls", "EOperationLog.cls", "EAuthData.cls")
        
        Case "utils", "utilidades", "enumeraciones"
            ' Seccion 11 - Utilidades y Enumeraciones
            arrFiles = Array("modRepositoryFactory.bas", "modEnumeraciones.bas", "modQueries.bas", _
                           "ModAppManagerFactory.bas", "modAuthFactory.bas", "modConfigFactory.bas", _
                           "modDocumentServiceFactory.bas", "modErrorHandlerFactory.bas", _
                           "modExpedienteServiceFactory.bas", "modFileSystemFactory.bas", _
                           "modNotificationServiceFactory.bas", "modOperationLoggerFactory.bas", _
                           "modSolicitudServiceFactory.bas", "modWordManagerFactory.bas", _
                           "modWorkflowServiceFactory.bas")
        
        Case "forms", "formularios", "ui"
            ' Funcionalidad de Formularios - UI as Code
            arrFiles = Array("condor_cli.vbs")
            
        Case "cli", "infrastructure", "infraestructura"
            ' Funcionalidad CLI e Infraestructura
            arrFiles = Array("condor_cli.vbs")
            
        Case "condorcli"
            ' Funcionalidad especial para copiar condor_cli.vbs como .txt
            arrFiles = Array("condor_cli.vbs")
            
        Case "tests", "pruebas", "testing", "test"
            ' Seccion 12 - Archivos de Pruebas (Autodescubrimiento)
            arrFiles = Array()
        Case Else
            ' Funcionalidad no reconocida - devolver array vacio
            arrFiles = Array()
    End Select
    
    GetFunctionalityFiles = arrFiles
End Function

Sub BundleFunctionality()
    On Error Resume Next
    
    Dim strFunctionalityOrFiles, strDestPath, strBundlePath, timestamp
    
    ' Verificar argumentos
    If objArgs.Count < 2 Then
        WScript.Echo "[ERROR] Se requiere nombre de funcionalidad o lista de ficheros"
        WScript.Echo "Uso: cscript condor_cli.vbs bundle <funcionalidad | fichero1,fichero2,...> [ruta_destino]"
        WScript.Quit 1
    End If
    
    strFunctionalityOrFiles = objArgs(1)
    
    ' Determinar ruta de destino
    If objArgs.Count >= 3 Then
        strDestPath = objArgs(2)
    Else
        strDestPath = objFSO.GetParentFolderName(WScript.ScriptFullName)
    End If
    
    ' Crear timestamp
    timestamp = Year(Now) & Right("0" & Month(Now), 2) & Right("0" & Day(Now), 2) & "_" & _
                Right("0" & Hour(Now), 2) & Right("0" & Minute(Now), 2) & Right("0" & Second(Now), 2)
    
    ' Crear nombre de carpeta bundle
    Dim bundleName
    If InStr(strFunctionalityOrFiles, ",") > 0 Then
        bundleName = "bundle_custom_" & timestamp
    Else
        bundleName = "bundle_" & strFunctionalityOrFiles & "_" & timestamp
    End If
    strBundlePath = objFSO.BuildPath(strDestPath, bundleName)
    
    WScript.Echo "=== EMPAQUETANDO ARTEFACTOS ==="
    WScript.Echo "Buscando archivos en: " & strSourcePath
    WScript.Echo "Carpeta destino: " & strBundlePath
    
    ' Crear carpeta de destino
    If Not objFSO.FolderExists(strBundlePath) Then
        objFSO.CreateFolder strBundlePath
        If Err.Number <> 0 Then
            WScript.Echo "[ERROR] Error creando carpeta de destino: " & Err.Description
            WScript.Quit 1
        End If
    End If
    
    Dim arrFilesToBundle
    
    ' Logica de Deteccion Inteligente
    If InStr(strFunctionalityOrFiles, ",") > 0 Then
        ' MODO 1: Lista de ficheros explicita
        WScript.Echo "Modo: Lista de ficheros explicita."
        arrFilesToBundle = Split(strFunctionalityOrFiles, ",")
    Else
        ' MODO 2: Verificar si es funcionalidad conocida o archivo individual
        arrFilesToBundle = GetFunctionalityFiles(strFunctionalityOrFiles)
        
        If UBound(arrFilesToBundle) >= 0 Then
            ' Es una funcionalidad conocida
            WScript.Echo "Modo: Funcionalidad '" & strFunctionalityOrFiles & "'."
        Else
            ' No es funcionalidad conocida, buscar archivo individual en src
            Dim singleFilePath
            singleFilePath = objFSO.BuildPath(strSourcePath, strFunctionalityOrFiles)
            
            If objFSO.FileExists(singleFilePath) Then
                ' Archivo encontrado, tratarlo como lista de un elemento
                WScript.Echo "Modo: Archivo individual '" & strFunctionalityOrFiles & "'."
                ReDim arrFilesToBundle(0)
                arrFilesToBundle(0) = strFunctionalityOrFiles
            Else
                ' Archivo no encontrado
                WScript.Echo "[ERROR] '" & strFunctionalityOrFiles & "' no es una funcionalidad conocida ni un archivo existente en src."
                WScript.Echo "Funcionalidades disponibles: Auth, Document, Expediente, Solicitud, Workflow, Mapeo, Notification, Operation, Config, FileSystem, Word, Error, TestFramework, App, Models, Utils, Tests"
                WScript.Quit 1
            End If
        End If
    End If
    
    ' Llamar a la subrutina de ayuda para copiar los ficheros
    Call CopyFilesToBundle(arrFilesToBundle, strBundlePath)
    
    On Error GoTo 0
End Sub

Sub CopyFilesToBundle(arrFiles, strBundlePath)
    Dim copiedFiles, notFoundFiles
    copiedFiles = 0
    notFoundFiles = 0
    
    If UBound(arrFiles) < 0 Then
        WScript.Echo "[VERBOSE] La lista de ficheros a empaquetar esta vacia."
    End If

    Dim i, fileName, filePath, destFilePath
    For i = 0 To UBound(arrFiles)
        fileName = Trim(arrFiles(i))
        
        ' Caso especial para condorcli: copiar desde la raiz del proyecto
        If fileName = "condor_cli.vbs" And InStr(strBundlePath, "bundle_condorcli_") > 0 Then
            filePath = objFSO.BuildPath(objFSO.GetParentFolderName(WScript.ScriptFullName), fileName)
        Else
            filePath = objFSO.BuildPath(strSourcePath, fileName)
        End If
        
        If objFSO.FileExists(filePath) Then
            ' Copiar archivo con extension .txt añadida al directorio del bundle
            destFilePath = objFSO.BuildPath(strBundlePath, fileName & ".txt")
            objFSO.CopyFile filePath, destFilePath, True
            
            If Err.Number <> 0 Then
                WScript.Echo "  [ERROR] Error copiando " & fileName & ": " & Err.Description
                Err.Clear
            Else
                WScript.Echo "  [OK] " & fileName & " -> " & fileName & ".txt"
                copiedFiles = copiedFiles + 1
            End If
        Else
            WScript.Echo "  [ERROR] Archivo no encontrado: " & fileName
            notFoundFiles = notFoundFiles + 1
        End If
    Next
    
    WScript.Echo ""
    WScript.Echo "=== RESULTADO DEL EMPAQUETADO ==="
    WScript.Echo "Archivos copiados: " & copiedFiles
    WScript.Echo "Archivos no encontrados: " & notFoundFiles
    WScript.Echo "Ubicacion del paquete: " & strBundlePath
    
    If copiedFiles = 0 Then
        WScript.Echo "[ERROR] No se copio ningun archivo."
    Else
        WScript.Echo "[OK] Empaquetado completado exitosamente"
    End If
End Sub

' Comando para listar modulos VBA con opciones avanzadas
Sub ListModulesCommand()
    On Error Resume Next
    Dim includeDocs, pattern, flagJson, expectSrc, flagDiff, dbPath, password
    Dim app, arr, i, ok
    
    ' Parsear flags
    includeDocs = HasFlag("includeDocs")
    pattern = GetArgValue("pattern")
    flagJson = HasFlag("json")
    expectSrc = HasFlag("expectSrc")
    flagDiff = HasFlag("diff")
    dbPath = GetArgValue("db")
    password = GetArgValue("password")
    
    ' Resolver contraseña si es necesario
    If password = "" Then password = ResolveDbPassword()
    
    ' Verificar instancia de Access existente o abrir nueva
    Set app = GetOrCreateAccessInstance(dbPath, password)
    If app Is Nothing Then
        WScript.Echo "[ERROR] No se pudo acceder a la instancia de Access"
        Exit Sub
    End If
    
    ' Intentar listar modulos usando diferentes metodos
    WScript.Echo "DEBUG: Intentando TryListModulesVBIDE..."
    ok = TryListModulesVBIDE(app, includeDocs, pattern, arr)
    If Not ok Then
        WScript.Echo "DEBUG: TryListModulesVBIDE fallo, intentando TryListModulesAllModules..."
        ok = TryListModulesAllModules(app, pattern, arr)
        If Not ok Then
            WScript.Echo "DEBUG: TryListModulesAllModules fallo, intentando TryListModulesDAO..."
            ok = TryListModulesDAO(app, pattern, arr)
        End If
    End If
    
    If Not ok Then
        WScript.Echo "[ERROR] No se pudieron listar los modulos"
        Exit Sub
    End If
    
    ' Mostrar resultados
    If flagJson Then
        PrintModulesJson arr
    Else
        PrintModulesText arr
    End If
    
    On Error GoTo 0
End Sub

' Comando para arreglar headers de archivos fuente
Sub FixSrcHeadersCommand()
    WScript.Echo "[INFO] Comando fix-src-headers no implementado aun"
    WScript.Echo "[INFO] Esta funcionalidad arreglara headers de archivos en /src"
End Sub

' Funciones auxiliares para ListModulesCommand
Function TryListModulesVBIDE(app, includeDocs, pattern, ByRef arr)
    On Error Resume Next
    ReDim arr(-1)
    
    Dim regex, p, comps, i, vbComp, kind, name, dict
    If pattern <> "" Then 
        Set regex = CreateObject("VBScript.RegExp")
        regex.Pattern = pattern
        regex.IgnoreCase = True
    End If
    
    Set p = app.VBE.ActiveVBProject
    If Err.Number <> 0 Or p Is Nothing Then 
        Err.Clear
        TryListModulesVBIDE = False
        Exit Function
    End If
    
    Set comps = p.VBComponents
    If Err.Number <> 0 Or comps Is Nothing Then 
        Err.Clear
        TryListModulesVBIDE = False
        Exit Function
    End If

    For i = 1 To comps.Count
        Set vbComp = comps(i)
        Select Case vbComp.Type
            Case 1: kind = "STD"
            Case 2: kind = "CLS"
            Case 3: kind = "FRM"
            Case 100: kind = "RPT"
            Case Else: kind = "OTHER"
        End Select
        name = vbComp.Name
        
        If (kind = "FRM" Or kind = "RPT") And Not includeDocs Then
            ' omitir
        ElseIf pattern = "" Or regex.Test(name) Then
            If UBound(arr) = -1 Then 
                ReDim arr(0) 
            Else 
                ReDim Preserve arr(UBound(arr) + 1)
            End If
            Set dict = CreateObject("Scripting.Dictionary")
            dict.Add "kind", kind
            dict.Add "name", name
            Set arr(UBound(arr)) = dict
        End If
    Next

    TryListModulesVBIDE = (Err.Number = 0)
    On Error GoTo 0
End Function

Function TryListModulesAllModules(app, pattern, ByRef arr)
    On Error Resume Next
    ReDim arr(-1)
    
    If app.CurrentProject Is Nothing Then 
        TryListModulesAllModules = False
        Exit Function
    End If
    
    Dim mods, regex, m, name, dict
    If pattern <> "" Then 
        Set regex = CreateObject("VBScript.RegExp")
        regex.Pattern = pattern
        regex.IgnoreCase = True
    End If
    
    Set mods = app.CurrentProject.AllModules
    If Err.Number <> 0 Or mods Is Nothing Then 
        Err.Clear
        TryListModulesAllModules = False
        Exit Function
    End If

    For Each m In mods
        name = m.Name
        If pattern = "" Or regex.Test(name) Then
            If UBound(arr) = -1 Then 
                ReDim arr(0) 
            Else 
                ReDim Preserve arr(UBound(arr) + 1)
            End If
            Set dict = CreateObject("Scripting.Dictionary")
            dict.Add "kind", "STD"
            dict.Add "name", name
            Set arr(UBound(arr)) = dict
        End If
    Next
    
    TryListModulesAllModules = (Err.Number = 0)
    On Error GoTo 0
End Function

Function TryListModulesDAO(app, pattern, ByRef arr)
    On Error Resume Next
    ReDim arr(-1)
    
    If app Is Nothing Then 
        TryListModulesDAO = False
        Exit Function
    End If
    
    If app.CurrentProject Is Nothing Then 
        TryListModulesDAO = False
        Exit Function
    End If
    
    Dim regex, db, obj, name, dict, moduleCount
    If pattern <> "" Then 
        Set regex = CreateObject("VBScript.RegExp")
        regex.Pattern = pattern
        regex.IgnoreCase = True
    End If
    
    Set db = app.CurrentProject
    If Err.Number <> 0 Then
        Err.Clear
        TryListModulesDAO = False
        Exit Function
    End If
    
    moduleCount = 0
    For Each obj In db.AllModules
        If Err.Number = 0 Then
            name = obj.Name
            If Err.Number = 0 Then
                If pattern = "" Or regex.Test(name) Then
                    If UBound(arr) = -1 Then 
                        ReDim arr(0) 
                    Else 
                        ReDim Preserve arr(UBound(arr) + 1)
                    End If
                    Set dict = CreateObject("Scripting.Dictionary")
                    dict.Add "kind", "STD"
                    dict.Add "name", name
                    Set arr(UBound(arr)) = dict
                    moduleCount = moduleCount + 1
                End If
            Else
                Err.Clear
            End If
        Else
            Err.Clear
        End If
    Next
    
    TryListModulesDAO = (moduleCount > 0)
    On Error GoTo 0
End Function

Sub PrintModulesText(arr)
    Dim total, i
    total = 0
    If IsArray(arr) Then 
        If UBound(arr) >= 0 Then 
            total = UBound(arr) + 1
        End If
    End If
    
    WScript.Echo "KIND  Name"
    WScript.Echo "----  ----"
    
    If total > 0 Then
        For i = 0 To UBound(arr)
            WScript.Echo arr(i)("kind") & "   " & arr(i)("name")
        Next
    End If
    
    WScript.Echo ""
    WScript.Echo "Total: " & total & " modulos"
End Sub

Sub PrintModulesJson(arr)
    Dim total, i, json
    total = 0
    If IsArray(arr) Then 
        If UBound(arr) >= 0 Then 
            total = UBound(arr) + 1
        End If
    End If
    
    json = "{"
    json = json & """modules"": ["
    
    If total > 0 Then
        For i = 0 To UBound(arr)
            If i > 0 Then json = json & ","
            json = json & "{"
            json = json & """kind"": """ & arr(i)("kind") & ""","
            json = json & """name"": """ & arr(i)("name") & """"
            json = json & "}"
        Next
    End If
    
    json = json & "],"
    json = json & """total"": " & total
    json = json & "}"
    
    WScript.Echo json
End Sub
