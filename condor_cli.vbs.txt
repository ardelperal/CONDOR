' CONDOR CLI - Herramienta de linea de comandos para el proyecto CONDOR
' Funcionalidades: Sincronizacion VBA, gestion de tablas, y operaciones del proyecto
' Version sin dialogos para automatizacion completa

Option Explicit

Dim objAccess
Dim strAccessPath
Dim strSourcePath
Dim strAction
Dim objFSO
Dim objArgs
Dim strDbPassword

' Configuracion
' Configuracion inicial - se determinara la base de datos segun la accion
Dim strDataPath
strAccessPath = "C:\Proyectos\CONDOR\back\Desarrollo\CONDOR.accdb"
strDataPath = "C:\Proyectos\CONDOR\back\CONDOR_datos.accdb"
strSourcePath = "C:\Proyectos\CONDOR\src"

' Obtener argumentos de linea de comandos
Set objArgs = WScript.Arguments
If objArgs.Count = 0 Or LCase(objArgs(0)) = "help" Then
    WScript.Echo "=== CONDOR CLI - Herramienta de linea de comandos ==="
    WScript.Echo "Uso: cscript condor_cli.vbs [comando] [opciones]"
    WScript.Echo ""
    WScript.Echo "COMANDOS DISPONIBLES:"
    WScript.Echo "  export     - Exportar modulos VBA a /src (con codificacion ANSI)"
    WScript.Echo "  validate   - Validar sintaxis de modulos VBA sin importar"
    WScript.Echo "  test       - Ejecutar suite de pruebas unitarias"
    WScript.Echo "  update     - Sincronizacion inteligente: automatica (sin args) o selectiva (con args)"
    WScript.Echo "  rebuild    - Reconstruir proyecto VBA (eliminar todos los modulos y reimportar)"
    WScript.Echo "  compile    - Compilar todos los modulos VBA del proyecto"
    WScript.Echo "  lint       - Auditar codigo VBA para detectar cabeceras duplicadas"
    WScript.Echo "  createtable <nombre> <sql> - Crear tabla con consulta SQL"
    WScript.Echo "  droptable <nombre> - Eliminar tabla"
    WScript.Echo "  listtables [db_path] - Listar tablas (opcionalmente de base especifica)"
    WScript.Echo "  relink <db_path> <folder> - Re-vincular tablas a bases locales"
    WScript.Echo "  relink --all - Re-vincular todas las bases en ./back automaticamente"
    WScript.Echo ""
    WScript.Echo "FLUJO DE TRABAJO RECOMENDADO:"
    WScript.Echo "  1. cscript condor_cli.vbs update            (sincronizacion automatica)"
    WScript.Echo "  2. cscript condor_cli.vbs update [modulos]  (actualizacion selectiva)"
    WScript.Echo "  3. cscript condor_cli.vbs rebuild           (reconstruccion completa si hay problemas)"
    WScript.Echo ""
    WScript.Echo "MODOS DEL COMANDO UPDATE:"
    WScript.Echo ""
    WScript.Echo "  MODO AUTOMATICO (sin argumentos):"
    WScript.Echo "    cscript condor_cli.vbs update"
    WScript.Echo "    - Sincronizacion incremental inteligente"
    WScript.Echo "    - Detecta archivos nuevos, modificados y eliminados"
    WScript.Echo "    - Compara fechas de modificacion automaticamente"
    WScript.Echo "    - Usa carpeta temporal .vba_cache para comparacion"
    WScript.Echo ""
    WScript.Echo "  MODO SELECTIVO (con argumentos):"
    WScript.Echo "    cscript condor_cli.vbs update CAuthService           (un solo modulo)"
    WScript.Echo "    cscript condor_cli.vbs update CAuthService,modUtils  (multiples modulos)"
    WScript.Echo "    cscript condor_cli.vbs update CConfig,CSolicitudService,modDatabase"
    WScript.Echo "    - Actualizacion rapida de modulos especificos"
    WScript.Echo "    - Elimina y reimporta solo los modulos indicados"
    WScript.Echo "    - Ideal para cambios puntuales durante desarrollo"
    WScript.Echo ""
    WScript.Echo "NOTAS IMPORTANTES:"
    WScript.Echo "  - MODO AUTOMATICO: Recomendado para sincronizacion diaria"
    WScript.Echo "  - MODO SELECTIVO: Separar nombres con comas (sin espacios)"
    WScript.Echo "  - No incluir extension (.bas/.cls) en los nombres"
    WScript.Echo "  - Solo se procesan modulos que existen en /src"
    WScript.Echo ""
    WScript.Echo "OPCIONES ESPECIALES:"
    WScript.Echo "  --dry-run  - Simular operacion sin modificar Access (solo con import)"
    WScript.Echo "  --verbose  - Mostrar informacion detallada durante la operacion"
    WScript.Echo ""
    WScript.Echo "OTROS EJEMPLOS:"
    WScript.Echo "  cscript condor_cli.vbs validate"
    WScript.Echo "  cscript condor_cli.vbs export --verbose"
    WScript.Echo "  cscript condor_cli.vbs rebuild"
    WScript.Quit 1
End If

strAction = LCase(objArgs(0))

If strAction <> "export" And strAction <> "validate" And strAction <> "test" And strAction <> "createtable" And strAction <> "droptable" And strAction <> "listtables" And strAction <> "relink" And strAction <> "update" And strAction <> "rebuild" And strAction <> "lint" And strAction <> "compile" Then
    WScript.Echo "Error: Comando debe ser 'export', 'validate', 'test', 'createtable', 'droptable', 'listtables', 'relink', 'update', 'rebuild', 'lint' o 'compile'"
    WScript.Quit 1
End If

Set objFSO = CreateObject("Scripting.FileSystemObject")

' Determinar qué base de datos usar según la acción
If strAction = "createtable" Or strAction = "droptable" Then
    strAccessPath = strDataPath
ElseIf strAction = "listtables" Then
    ' Para listtables, usar base específica si se proporciona, sino usar por defecto
    If objArgs.Count > 1 Then
        strAccessPath = objArgs(1)
    Else
        strAccessPath = strDataPath
    End If
End If

' Para update, rebuild y test, usar la base de datos de desarrollo
If strAction = "update" Or strAction = "rebuild" Or strAction = "test" Then
    strAccessPath = "C:\Proyectos\CONDOR\back\Desarrollo\CONDOR.accdb"
End If

' Verificar que existe la base de datos
If Not objFSO.FileExists(strAccessPath) Then
    WScript.Echo "Error: La base de datos no existe: " & strAccessPath
    WScript.Quit 1
End If

WScript.Echo "=== INICIANDO SINCRONIZACION VBA ==="
WScript.Echo "Accion: " & strAction
WScript.Echo "Base de datos: " & strAccessPath
WScript.Echo "Directorio: " & strSourcePath

' Verificar y cerrar procesos de Access existentes
Call CloseExistingAccessProcesses()

On Error Resume Next

' Crear aplicacion Access
WScript.Echo "Iniciando aplicacion Access..."
Set objAccess = CreateObject("Access.Application")

If Err.Number <> 0 Then
    WScript.Echo "Error al crear aplicacion Access: " & Err.Description
    WScript.Quit 1
End If

' Configurar Access en modo silencioso
objAccess.Visible = False
objAccess.UserControl = False
' Suprimir alertas y diálogos de confirmación
objAccess.DoCmd.SetWarnings False
objAccess.Application.Echo False
' Configuraciones adicionales para suprimir diálogos
On Error Resume Next
objAccess.Application.AutomationSecurity = 1  ' msoAutomationSecurityLow
objAccess.VBE.MainWindow.Visible = False
Err.Clear
On Error GoTo 0

' Abrir base de datos con compilacion condicional
WScript.Echo "Abriendo base de datos..."

' Configurar Access para evitar errores de compilación
On Error Resume Next
' Intentar configurar propiedades si están disponibles
objAccess.DisplayAlerts = False
Err.Clear

' Determinar contraseña para la base de datos
strDbPassword = GetDatabasePassword(strAccessPath)

' Abrir base de datos con manejo de errores robusto
If strDbPassword = "" Then
    ' Sin contraseña
    objAccess.OpenCurrentDatabase strAccessPath
Else
    ' Con contrasena - usar solo dos parametros
    objAccess.OpenCurrentDatabase strAccessPath, , strDbPassword
End If

If Err.Number <> 0 Then
    WScript.Echo "Error al abrir base de datos: " & Err.Description
    objAccess.Quit
    WScript.Quit 1
End If

On Error GoTo 0
WScript.Echo "Base de datos abierta correctamente (modo seguro)"

' Verificar opciones especiales
Dim bDryRun, bVerbose, i
bDryRun = False
bVerbose = False

For i = 1 To objArgs.Count - 1
    If LCase(objArgs(i)) = "--dry-run" Then
        bDryRun = True
        WScript.Echo "[MODO DRY-RUN] Simulacion activada - no se modificara Access"
    ElseIf LCase(objArgs(i)) = "--verbose" Then
        bVerbose = True
        WScript.Echo "[MODO VERBOSE] Informacion detallada activada"
    End If
Next

If strAction = "validate" Then
    Call ValidateAllModules(bVerbose)
ElseIf strAction = "export" Then
    Call ExportModules(bVerbose)
ElseIf strAction = "test" Then
    Call ExecuteTests()
ElseIf strAction = "createtable" Then
    Call CreateTable()
ElseIf strAction = "droptable" Then
    Call DropTable()
ElseIf strAction = "listtables" Then
    Call ListTables()

ElseIf strAction = "update" Then
    Call UpdateProject()
ElseIf strAction = "rebuild" Then
    Call RebuildProject()
ElseIf strAction = "compile" Then
    Call CompileProject()
ElseIf strAction = "lint" Then
    Call LintProject()
ElseIf strAction = "relink" Then
    Call RelinkTables()
End If

' Cerrar Access
WScript.Echo "Cerrando Access..."
' Restaurar estado normal de Access antes de cerrar
On Error Resume Next
objAccess.Application.Echo True
objAccess.Quit 1  ' acQuitSaveAll = 1
If Err.Number <> 0 Then
    ' Intentar cerrar sin guardar si hay problemas
    objAccess.Quit 2  ' acQuitSaveNone = 2
End If
On Error GoTo 0
WScript.Echo "Access cerrado correctamente"

WScript.Echo "=== SINCRONIZACION COMPLETADA EXITOSAMENTE ==="
WScript.Quit 0

' Subrutina para validar todos los modulos sin importar
Sub ValidateAllModules(bVerbose)
    Dim objFolder, objFile
    Dim strFileName, strContent
    Dim validationResult
    Dim totalFiles, validFiles, invalidFiles
    
    WScript.Echo "=== VALIDACION DE SINTAXIS VBA ==="
    
    If Not objFSO.FolderExists(strSourcePath) Then
        WScript.Echo "Error: Directorio de origen no existe: " & strSourcePath
        WScript.Quit 1
    End If
    
    Set objFolder = objFSO.GetFolder(strSourcePath)
    totalFiles = 0
    validFiles = 0
    invalidFiles = 0
    
    For Each objFile In objFolder.Files
        If LCase(objFSO.GetExtensionName(objFile.Name)) = "bas" Or LCase(objFSO.GetExtensionName(objFile.Name)) = "cls" Then
            totalFiles = totalFiles + 1
            strFileName = objFile.Path
            
            If bVerbose Then
                WScript.Echo "Validando: " & objFile.Name
            End If
            
            ' Validar sintaxis
            Dim errorDetails
            validationResult = ValidateVBASyntax(strFileName, errorDetails)
            
            If validationResult = True Then
                validFiles = validFiles + 1
                If bVerbose Then
                    WScript.Echo "  ✓ Sintaxis valida"
                End If
            Else
                invalidFiles = invalidFiles + 1
                WScript.Echo "  ✗ ERROR en " & objFile.Name & ": " & errorDetails
            End If
        End If
    Next
    
    WScript.Echo ""
    WScript.Echo "=== RESUMEN DE VALIDACION ==="
    WScript.Echo "Total de archivos: " & totalFiles
    WScript.Echo "Archivos validos: " & validFiles
    WScript.Echo "Archivos con errores: " & invalidFiles
    
    If invalidFiles > 0 Then
        WScript.Echo "ADVERTENCIA: Se encontraron errores de sintaxis. Corrija antes de importar."
        WScript.Quit 1
    Else
        WScript.Echo "✓ Todos los archivos tienen sintaxis valida"
    End If
End Sub



' Subrutina para exportar modulos
Sub ExportModules(bVerbose)
    Dim vbComponent
    Dim strExportPath
    Dim exportedCount
    
    WScript.Echo "Iniciando exportacion de modulos VBA..."
    
    If Not objFSO.FolderExists(strSourcePath) Then
        objFSO.CreateFolder strSourcePath
        WScript.Echo "Directorio de destino creado: " & strSourcePath
    End If
    
    exportedCount = 0
    
    For Each vbComponent In objAccess.VBE.ActiveVBProject.VBComponents
        If vbComponent.Type = 1 Then  ' vbext_ct_StdModule
            strExportPath = strSourcePath & "\" & vbComponent.Name & ".bas"
            
            If bVerbose Then
                WScript.Echo "Exportando modulo: " & vbComponent.Name
            End If
            
            On Error Resume Next
            Call ExportModuleWithAnsiEncoding(vbComponent, strExportPath)
            
            If Err.Number <> 0 Then
                WScript.Echo "Error al exportar modulo " & vbComponent.Name & ": " & Err.Description
                Err.Clear
            Else
                If bVerbose Then
                    WScript.Echo "  ✓ Modulo " & vbComponent.Name & " exportado a: " & strExportPath
                Else
                    WScript.Echo "✓ " & vbComponent.Name & ".bas"
                End If
                exportedCount = exportedCount + 1
            End If
        ElseIf vbComponent.Type = 2 Then  ' vbext_ct_ClassModule
            strExportPath = strSourcePath & "\" & vbComponent.Name & ".cls"
            
            If bVerbose Then
                WScript.Echo "Exportando clase: " & vbComponent.Name
            End If
            
            On Error Resume Next
            Call ExportModuleWithAnsiEncoding(vbComponent, strExportPath)
            
            If Err.Number <> 0 Then
                WScript.Echo "Error al exportar clase " & vbComponent.Name & ": " & Err.Description
                Err.Clear
            Else
                If bVerbose Then
                    WScript.Echo "  ✓ Clase " & vbComponent.Name & " exportada a: " & strExportPath
                Else
                    WScript.Echo "✓ " & vbComponent.Name & ".cls"
                End If
                exportedCount = exportedCount + 1
            End If
        End If
    Next
    
    WScript.Echo "Exportacion completada exitosamente. Modulos exportados: " & exportedCount
End Sub

' Subrutina para crear tabla
Sub CreateTable()
    Dim strTableName
    Dim strSQL
    Dim strQueryName
    
    If objArgs.Count < 3 Then
        WScript.Echo "Error: Se requiere nombre de tabla y consulta SQL"
        WScript.Echo "Uso: cscript condor_cli.vbs createtable <nombre> <sql>"
        WScript.Quit 1
    End If
    
    strTableName = objArgs(1)
    strSQL = objArgs(2)
    strQueryName = "qry_Create_" & strTableName
    
    WScript.Echo "Creando tabla: " & strTableName
    WScript.Echo "SQL: " & strSQL
    
    On Error Resume Next
    
    ' Verificar si la tabla ya existe
    Dim tblExists
    tblExists = False
    Dim tbl
    For Each tbl In objAccess.CurrentDb.TableDefs
        If LCase(tbl.Name) = LCase(strTableName) Then
            tblExists = True
            Exit For
        End If
    Next
    
    If tblExists Then
        WScript.Echo "Advertencia: La tabla '" & strTableName & "' ya existe"
    End If
    
    ' Crear consulta temporal
    WScript.Echo "Creando consulta temporal: " & strQueryName
    objAccess.CurrentDb.CreateQueryDef strQueryName, strSQL
    
    If Err.Number <> 0 Then
        WScript.Echo "Error al crear consulta: " & Err.Description
        Err.Clear
        Exit Sub
    End If
    
    ' Ejecutar consulta
    WScript.Echo "Ejecutando consulta..."
    objAccess.DoCmd.OpenQuery strQueryName
    
    If Err.Number <> 0 Then
        WScript.Echo "Error al ejecutar consulta: " & Err.Description
        Err.Clear
    Else
        WScript.Echo "Tabla '" & strTableName & "' creada exitosamente"
    End If
    
    ' Eliminar consulta temporal
    WScript.Echo "Eliminando consulta temporal..."
    objAccess.DoCmd.DeleteObject 1, strQueryName  ' acQuery = 1
    
    If Err.Number <> 0 Then
        WScript.Echo "Advertencia al eliminar consulta: " & Err.Description
        Err.Clear
    Else
        WScript.Echo "Consulta temporal eliminada"
    End If
    
    ' Verificar que la tabla fue creada
    Call VerifyTable(strTableName)
End Sub

' Subrutina para eliminar tabla
Sub DropTable()
    Dim strTableName
    
    If objArgs.Count < 2 Then
        WScript.Echo "Error: Se requiere nombre de tabla"
        WScript.Echo "Uso: cscript condor_cli.vbs droptable <nombre>"
        WScript.Quit 1
    End If
    
    strTableName = objArgs(1)
    
    WScript.Echo "Eliminando tabla: " & strTableName
    
    On Error Resume Next
    objAccess.DoCmd.DeleteObject 0, strTableName  ' acTable = 0
    
    If Err.Number <> 0 Then
        WScript.Echo "Error al eliminar tabla: " & Err.Description
        Err.Clear
    Else
        WScript.Echo "Tabla '" & strTableName & "' eliminada exitosamente"
    End If
End Sub

' Subrutina para listar tablas
Sub ListTables()
    Dim tbl
    Dim tableCount
    
    WScript.Echo "=== LISTADO DE TABLAS ==="
    tableCount = 0
    
    For Each tbl In objAccess.CurrentDb.TableDefs
        ' Filtrar tablas del sistema (que empiezan con MSys)
        If Left(tbl.Name, 4) <> "MSys" And Left(tbl.Name, 1) <> "~" Then
            tableCount = tableCount + 1
            WScript.Echo tableCount & ". " & tbl.Name & " (" & tbl.RecordCount & " registros)"
        End If
    Next
    
    If tableCount = 0 Then
        WScript.Echo "No se encontraron tablas de usuario"
    Else
        WScript.Echo "Total de tablas: " & tableCount
    End If
End Sub

' Subrutina para verificar tabla creada
Sub VerifyTable(strTableName)
    Dim tbl
    Dim found
    
    WScript.Echo "Verificando tabla creada..."
    found = False
    
    On Error Resume Next
    For Each tbl In objAccess.CurrentDb.TableDefs
        If LCase(tbl.Name) = LCase(strTableName) Then
            found = True
            WScript.Echo "? Tabla '" & strTableName & "' verificada exitosamente"
            WScript.Echo "  - Campos: " & tbl.Fields.Count
            WScript.Echo "  - Registros: " & tbl.RecordCount
            Exit For
        End If
    Next
    
    If Not found Then
        WScript.Echo "? Error: No se pudo verificar la tabla '" & strTableName & "'"
    End If
End Sub




' ===================================================================
' SUBRUTINA: LintProject
' Descripción: Audita el código VBA para detectar cabeceras duplicadas
' ===================================================================
Sub LintProject()
    Dim vbComponent, codeModule
    Dim lineContent, moduleName
    Dim optionCompareCount, optionExplicitCount
    Dim i, hasErrors
    
    WScript.Echo "=== INICIANDO AUDITORIA VBA ==="
    WScript.Echo "Accion: lint"
    WScript.Echo "Base de datos: " & strAccessPath
    
    Set objAccess = CreateObject("Access.Application")
    objAccess.Visible = False
    objAccess.OpenCurrentDatabase strAccessPath, False
    
    WScript.Echo "=== AUDITORIA DE CABECERAS VBA ==="
    WScript.Echo ""
    
    hasErrors = False
    
    For Each vbComponent In objAccess.VBE.ActiveVBProject.VBComponents
        moduleName = vbComponent.Name
        Set codeModule = vbComponent.CodeModule
        
        optionCompareCount = 0
        optionExplicitCount = 0
        
        For i = 1 To 10
            If i <= codeModule.CountOfLines Then
                lineContent = Trim(codeModule.Lines(i, 1))
                
                If InStr(1, lineContent, "Option Compare", 1) > 0 Then
                    optionCompareCount = optionCompareCount + 1
                End If
                
                If InStr(1, lineContent, "Option Explicit", 1) > 0 Then
                    optionExplicitCount = optionExplicitCount + 1
                End If
            End If
        Next
        
        If optionCompareCount > 1 Then
            WScript.Echo "ERROR: Modulo " & moduleName & " tiene " & optionCompareCount & " declaraciones Option Compare duplicadas"
            hasErrors = True
        End If
        
        If optionExplicitCount > 1 Then
            WScript.Echo "ERROR: Modulo " & moduleName & " tiene " & optionExplicitCount & " declaraciones Option Explicit duplicadas"
            hasErrors = True
        End If
        
        If optionCompareCount <= 1 And optionExplicitCount <= 1 Then
            WScript.Echo "OK: " & moduleName & " - Cabeceras correctas"
        End If
    Next
    
    If hasErrors Then
        WScript.Echo ""
        WScript.Echo "=== LINT FALLIDO ==="
        WScript.Echo "Se encontraron cabeceras duplicadas."
        objAccess.Quit
        WScript.Quit 1
    Else
        WScript.Echo ""
        WScript.Echo "=== LINT COMPLETADO EXITOSAMENTE ==="
    End If
    
    objAccess.Quit
End Sub

' Subrutina para compilación condicional de módulos
Sub CompileModulesConditionally()
    Dim vbComponent
    Dim compilationErrors
    Dim totalModules
    Dim compiledModules
    
    WScript.Echo "Iniciando compilación condicional de módulos..."
    
    compilationErrors = 0
    totalModules = 0
    compiledModules = 0
    
    ' Intentar compilar cada módulo individualmente (módulos estándar y clases)
    For Each vbComponent In objAccess.VBE.ActiveVBProject.VBComponents
        If vbComponent.Type = 1 Or vbComponent.Type = 2 Then  ' vbext_ct_StdModule o vbext_ct_ClassModule
            totalModules = totalModules + 1
            
            On Error Resume Next
            Err.Clear
            
            ' Intentar compilar el módulo específico
            If vbComponent.Type = 1 Then
                WScript.Echo "Compilando módulo: " & vbComponent.Name
            Else
                WScript.Echo "Compilando clase: " & vbComponent.Name
            End If
            
            ' Verificar si el módulo tiene errores de sintaxis
            Dim hasErrors
            hasErrors = False
            
            ' Intentar acceder al código del módulo para detectar errores
            Dim moduleCode
            moduleCode = vbComponent.CodeModule.Lines(1, vbComponent.CodeModule.CountOfLines)
            
            If Err.Number <> 0 Then
                WScript.Echo "  ⚠️ Error en " & vbComponent.Name & ": " & Err.Description
                compilationErrors = compilationErrors + 1
                hasErrors = True
                Err.Clear
            Else
                ' Intentar compilar usando DoCmd.Save con el tipo correcto
                If vbComponent.Type = 1 Then
                    objAccess.DoCmd.Save 5, vbComponent.Name  ' acModule = 5
                    
                    If Err.Number <> 0 Then
                        WScript.Echo "  ⚠️ Advertencia al guardar " & vbComponent.Name & ": " & Err.Description
                        compilationErrors = compilationErrors + 1
                        hasErrors = True
                        Err.Clear
                    Else
                        WScript.Echo "  ✓ " & vbComponent.Name & " compilado correctamente"
                        compiledModules = compiledModules + 1
                    End If
                Else
                    ' Para módulos de clase, solo verificar sintaxis sin intentar guardar individualmente
                    WScript.Echo "  ✓ " & vbComponent.Name & " verificado (clase)"
                    compiledModules = compiledModules + 1
                End If
            End If
            
            On Error GoTo 0
        End If
    Next
    
    ' Intentar compilación global si los módulos principales están bien
    If compiledModules >= (totalModules - 3) Then  ' Permitir hasta 3 errores (las clases problemáticas)
        WScript.Echo "Intentando compilación global..."
        On Error Resume Next
        objAccess.DoCmd.RunCommand 636  ' acCmdCompileAndSaveAllModules
        
        If Err.Number <> 0 Then
            WScript.Echo "⚠️ Advertencia en compilación global: " & Err.Description
            WScript.Echo "Continuando con módulos compilados individualmente..."
            Err.Clear
        Else
            WScript.Echo "✓ Compilación global exitosa"
        End If
        On Error GoTo 0
    Else
        WScript.Echo "⚠️ Se encontraron " & compilationErrors & " errores de compilación"
        WScript.Echo "Continuando sin compilación global para evitar bloqueos..."
    End If
    
    WScript.Echo "Resumen de compilación:"
    WScript.Echo "  - Total de módulos: " & totalModules
    WScript.Echo "  - Módulos compilados: " & compiledModules
    WScript.Echo "  - Errores encontrados: " & compilationErrors
    
    If compilationErrors > 0 Then
        WScript.Echo "⚠️ ADVERTENCIA: Algunos módulos tienen errores de compilación"
        WScript.Echo "El CLI continuará funcionando, pero revise los módulos con errores"
    End If
End Sub

' Subrutina para verificar que los nombres de módulos coincidan con src
Sub VerifyModuleNames()
    Dim objFolder, objFile
    Dim vbComponent
    Dim srcModules, accessModules
    Dim moduleName
    Dim discrepancies
    
    WScript.Echo "Verificando integridad de nombres de módulos..."
    
    ' Crear diccionarios para comparación
    Set srcModules = CreateObject("Scripting.Dictionary")
    Set accessModules = CreateObject("Scripting.Dictionary")
    discrepancies = 0
    
    ' Obtener lista de módulos en src
    Set objFolder = objFSO.GetFolder(strSourcePath)
    For Each objFile In objFolder.Files
        If LCase(objFSO.GetExtensionName(objFile.Name)) = "bas" Or LCase(objFSO.GetExtensionName(objFile.Name)) = "cls" Then
            moduleName = objFSO.GetBaseName(objFile.Name)
            srcModules.Add moduleName, True
        End If
    Next
    
    ' Obtener lista de módulos en Access
    For Each vbComponent In objAccess.VBE.ActiveVBProject.VBComponents
        If vbComponent.Type = 1 Or vbComponent.Type = 2 Then  ' vbext_ct_StdModule o vbext_ct_ClassModule
            accessModules.Add vbComponent.Name, True
        End If
    Next
    
    ' Verificar que todos los módulos de src estén en Access
    For Each moduleName In srcModules.Keys
        If Not accessModules.Exists(moduleName) Then
            WScript.Echo "⚠️ ERROR: Módulo '" & moduleName & "' existe en src pero no en Access"
            discrepancies = discrepancies + 1
        End If
    Next
    
    ' Verificar que todos los módulos de Access estén en src
    For Each moduleName In accessModules.Keys
        If Not srcModules.Exists(moduleName) Then
            WScript.Echo "⚠️ ERROR: Módulo '" & moduleName & "' existe en Access pero no en src"
            discrepancies = discrepancies + 1
        End If
    Next
    
    ' Reporte final
    If discrepancies = 0 Then
        WScript.Echo "✓ Verificación exitosa: Todos los módulos coinciden entre src y Access"
        WScript.Echo "  - Módulos en src: " & srcModules.Count
        WScript.Echo "  - Módulos en Access: " & accessModules.Count
    Else
        WScript.Echo "❌ FALLO EN VERIFICACIÓN: Se encontraron " & discrepancies & " discrepancias"
        WScript.Echo "⚠️ ACCIÓN REQUERIDA: Revise la sincronización entre src y Access"
    End If
End Sub

' Función para validar sintaxis VBA antes de importar
Function ValidateVBASyntax(filePath, ByRef errorDetails)
    Dim objFile, strContent
    
    errorDetails = ""
    
    ' Leer archivo con codificación ANSI
    On Error Resume Next
    Set objFile = objFSO.OpenTextFile(filePath, 1, False, 0)
    If Err.Number <> 0 Then
        errorDetails = "Error al leer archivo: " & Err.Description
        ValidateVBASyntax = False
        Exit Function
    End If
    
    strContent = objFile.ReadAll
    objFile.Close
    On Error GoTo 0
    
    ' Validación básica: verificar que el archivo no esté vacío y sea legible
    If Len(Trim(strContent)) = 0 Then
        errorDetails = "El archivo está vacío"
        ValidateVBASyntax = False
        Exit Function
    End If
    
    ' Verificar caracteres problemáticos básicos
    If InStr(strContent, Chr(0)) > 0 Then
        errorDetails = "El archivo contiene caracteres nulos"
        ValidateVBASyntax = False
        Exit Function
    End If
    
    ' Si llegamos aquí, el archivo es válido
    ValidateVBASyntax = True
End Function

' Función para leer archivo con codificación ANSI
Function ReadFileWithAnsiEncoding(filePath)
    Dim objStream, strContent
    
    On Error Resume Next
    
    ' Leer contenido del archivo usando ADODB.Stream con UTF-8
    Set objStream = CreateObject("ADODB.Stream")
    objStream.Type = 2 ' adTypeText
    objStream.Charset = "UTF-8"
    objStream.Open
    objStream.LoadFromFile filePath
    strContent = objStream.ReadText
    objStream.Close
    Set objStream = Nothing
    
    If Err.Number <> 0 Then
        WScript.Echo "❌ ERROR: No se pudo leer el archivo " & filePath & ": " & Err.Description
        ReadFileWithAnsiEncoding = ""
        Err.Clear
        On Error GoTo 0
        Exit Function
    End If
    
    On Error GoTo 0
    ReadFileWithAnsiEncoding = strContent
End Function

' Función para verificar y corregir líneas Option en archivo fuente
' Función para limpiar archivos VBA eliminando líneas Attribute con validación mejorada
Function CleanVBAFile(filePath, fileType)
    Dim objStream, strContent, arrLines, i, cleanedLines
    Dim strLine, errorDetails
    
    ' Usar el tipo de archivo pasado como parámetro ("bas" o "cls")
    ' fileType debe ser "bas" o "cls"
    
    ' Validar sintaxis antes de procesar
    If Not ValidateVBASyntax(filePath, errorDetails) Then
        WScript.Echo "[WARN] ADVERTENCIA: Errores de sintaxis detectados en " & objFSO.GetFileName(filePath) & ":"
        WScript.Echo errorDetails
        WScript.Echo "Continuando con la importación..."
    End If
    
    ' Leer contenido del archivo usando ADODB.Stream con UTF-8
    On Error Resume Next
    Set objStream = CreateObject("ADODB.Stream")
    objStream.Type = 2 ' adTypeText
    objStream.Charset = "UTF-8"
    objStream.Open
    objStream.LoadFromFile filePath
    strContent = objStream.ReadText
    objStream.Close
    Set objStream = Nothing
    
    If Err.Number <> 0 Then
        WScript.Echo "❌ ERROR: No se pudo leer el archivo " & filePath & ": " & Err.Description
        CleanVBAFile = ""
        Err.Clear
        On Error GoTo 0
        Exit Function
    End If
    
    On Error GoTo 0
    
    ' Normalizar saltos de línea y dividir
    strContent = Replace(strContent, vbCrLf, vbLf)
    strContent = Replace(strContent, vbCr, vbLf)
    arrLines = Split(strContent, vbLf)
    
    ' Procesar línea por línea eliminando SOLO metadatos (NO líneas Option)
    cleanedLines = ""
    Dim linesRemoved
    linesRemoved = 0
    
    For i = 0 To UBound(arrLines)
        strLine = Trim(arrLines(i))
        
        ' Verificar si es una línea que debe eliminarse
        Dim shouldRemove
        shouldRemove = False
        
        ' SIEMPRE eliminar metadatos Attribute y VERSION para ambos tipos
        If Left(strLine, 7) = "VERSION" Then shouldRemove = True
        If Left(strLine, 5) = "BEGIN" Then shouldRemove = True
        If Left(strLine, 8) = "MultiUse" Then shouldRemove = True
        If strLine = "END" Then shouldRemove = True
        If Left(strLine, 9) = "Attribute" Then shouldRemove = True
        
        ' ELIMINAR también las líneas Option - Access las añadirá automáticamente
        If strLine = "Option Compare Database" Then shouldRemove = True
        If strLine = "Option Explicit" Then shouldRemove = True
        
        ' Eliminar líneas vacías solo al inicio del archivo
        If strLine = "" And cleanedLines = "" Then shouldRemove = True
        
        ' Si la línea no debe eliminarse, agregarla al contenido limpio
        If Not shouldRemove Then
            ' Reemplazar caracteres problemáticos
            strLine = arrLines(i) ' Usar línea original (con espacios)
            strLine = Replace(strLine, Chr(147), Chr(34)) ' Comilla izquierda tipográfica -> comilla normal
            strLine = Replace(strLine, Chr(148), Chr(34)) ' Comilla derecha tipográfica -> comilla normal
            strLine = Replace(strLine, Chr(145), Chr(39)) ' Apostrofe izquierdo -> apostrofe normal
            strLine = Replace(strLine, Chr(146), Chr(39)) ' Apostrofe derecho -> apostrofe normal
            ' Reemplazar caracteres Unicode problemáticos
            strLine = Replace(strLine, "✓", "[OK]") ' Check mark -> [OK]
            strLine = Replace(strLine, "✗", "[FALLO]") ' X mark -> [FALLO]
            strLine = Replace(strLine, "└─", "  |-") ' Box drawing -> simple chars
            strLine = Replace(strLine, "✅", "[OK]") ' Green check -> [OK]
            strLine = Replace(strLine, "❌", "[ERROR]") ' Red X -> [ERROR]
            strLine = Replace(strLine, "⚠️", "[WARN]") ' Warning -> [WARN]
            
            If cleanedLines <> "" Then
                cleanedLines = cleanedLines & vbCrLf
            End If
            cleanedLines = cleanedLines & strLine
        Else
            linesRemoved = linesRemoved + 1
        End If
    Next
    
    ' Añadir Option Explicit como primera línea después de eliminar metadatos
    If cleanedLines <> "" Then
        cleanedLines = "Option Explicit" & vbCrLf & cleanedLines
    Else
        cleanedLines = "Option Explicit"
    End If
    
    WScript.Echo "  Eliminadas " & linesRemoved & " líneas de metadatos (archivo ." & fileType & ")"
    
    CleanVBAFile = cleanedLines
End Function

' Función para exportar módulo con conversión ANSI -> UTF-8 usando ADODB.Stream
Sub ExportModuleWithAnsiEncoding(vbComponent, strExportPath)
    Dim tempFilePath, objTempFile, objStream
    Dim strContent
    Dim tempFolderPath, tempFileName
    
    On Error Resume Next
    
    ' Crear archivo temporal usando el directorio temporal del sistema
    tempFolderPath = objFSO.GetSpecialFolder(2) ' El 2 es la constante para la carpeta temporal del sistema
    tempFileName = objFSO.GetTempName() ' Genera un nombre aleatorio y seguro como "radB93EB.tmp"
    tempFilePath = objFSO.BuildPath(tempFolderPath, tempFileName)
    
    ' Exportar a archivo temporal (Access usa ANSI internamente)
    vbComponent.Export tempFilePath
    
    ' Leer contenido del archivo temporal con codificación ANSI usando FSO
    Set objTempFile = objFSO.OpenTextFile(tempFilePath, 1, False, 0) ' ForReading = 1, Create = False, Format = 0 (ANSI)
    strContent = objTempFile.ReadAll
    objTempFile.Close
    
    ' Escribir al archivo final con codificación UTF-8 usando ADODB.Stream
    Set objStream = CreateObject("ADODB.Stream")
    objStream.Type = 2 ' adTypeText
    objStream.Charset = "UTF-8"
    objStream.Open
    objStream.WriteText strContent
    objStream.SaveToFile strExportPath, 2 ' adSaveCreateOverWrite
    objStream.Close
    Set objStream = Nothing
    
    ' Limpiar archivo temporal
    objFSO.DeleteFile tempFilePath
    
    If Err.Number <> 0 Then
        WScript.Echo "❌ ERROR en ExportModuleWithAnsiEncoding: " & Err.Description
        Err.Clear
    End If
    
    On Error GoTo 0
End Sub

' Subrutina para ejecutar la suite de pruebas unitarias
Sub ExecuteTests()
    WScript.Echo "=== INICIANDO EJECUCION DE PRUEBAS ==="
    Dim strLogPath, objLogFile, strLine, testsFailed
    strLogPath = "C:\Proyectos\CONDOR\logs\test_results.log"


    ' 1. Limpiar log anterior
    If objFSO.FileExists(strLogPath) Then objFSO.DeleteFile(strLogPath)

    ' 2. Ejecutar las pruebas en Access
    WScript.Echo "Ejecutando suite de pruebas en Access..."
    On Error Resume Next
    
    ' Verificar que la función ExecuteAllTests existe
    Dim testFunctionExists
    testFunctionExists = False
    
    ' Intentar verificar si la función existe en los módulos
    Dim vbComp, vbModule
    For Each vbComp In objAccess.VBE.ActiveVBProject.VBComponents
        If vbComp.Type = 1 Then ' vbext_ct_StdModule
            Set vbModule = vbComp.CodeModule
            If InStr(vbModule.Lines(1, vbModule.CountOfLines), "ExecuteAllTests") > 0 Then
                testFunctionExists = True
                WScript.Echo "✓ Función ExecuteAllTests encontrada en módulo: " & vbComp.Name
                Exit For
            End If
        End If
    Next
    
    If Not testFunctionExists Then
        WScript.Echo "ERROR: No se encontró la función ExecuteAllTests en ningún módulo VBA"
        WScript.Echo "SUGERENCIA: Verifica que el módulo modTestRunner.bas esté correctamente importado"
        objAccess.Quit
        WScript.Quit 1
    End If
    
    ' Ejecutar función wrapper sin parámetros
    objAccess.Application.Run "RunTests"

    If Err.Number <> 0 Then
        WScript.Echo "ERROR: Fallo crítico al invocar la suite de pruebas."
        WScript.Echo "  Código de Error: " & Err.Number
        WScript.Echo "  Descripción: " & Err.Description
        WScript.Echo "  Fuente: " & Err.Source
        WScript.Echo "SUGERENCIA: Abre Access manualmente y ejecuta ExecuteAllTests desde el módulo modTestRunner para ver el error específico"
        objAccess.Quit
        WScript.Quit 1
    End If
    On Error GoTo 0

    ' Access se cerrará automáticamente al final de las pruebas.
    ' Esperamos un momento para asegurar que el fichero de log se ha escrito.
    WScript.Sleep 2000

    ' 3. Leer y mostrar los resultados desde el log
    WScript.Echo "--- INICIO DE RESULTADOS DE PRUEBAS ---"
    testsFailed = True ' Asumir fallo hasta que se confirme el éxito
    If objFSO.FileExists(strLogPath) Then
        Set objLogFile = objFSO.OpenTextFile(strLogPath, 1) ' ForReading
        Do While Not objLogFile.AtEndOfStream
            strLine = objLogFile.ReadLine
            WScript.Echo strLine
            If InStr(strLine, "RESULT: SUCCESS") > 0 Then testsFailed = False
        Loop
        objLogFile.Close
    Else
        WScript.Echo "ERROR: No se encontró el fichero de resultados de pruebas."
    End If
    WScript.Echo "--- FIN DE RESULTADOS DE PRUEBAS ---"

    ' 4. Salir con el código de estado apropiado
    If testsFailed Then
        WScript.Echo "RESULTADO FINAL: ✗ Pruebas fallidas."
        WScript.Quit 1 ' Código de error para CI/CD
    Else
        WScript.Echo "RESULTADO FINAL: ✓ Todas las pruebas pasaron."
        WScript.Quit 0 ' Código de éxito
    End If
End Sub

' Función para importar módulo con conversión UTF-8 -> ANSI
Sub ImportModuleWithAnsiEncoding(strImportPath, moduleName, fileExtension, vbComponent, cleanedContent)
    ' Declarar variables locales
    Dim tempFolderPath, tempFileName, tempFilePath
    Dim objTempFile
    Dim importError, renameError, existingComponent
    
    If fileExtension = "bas" Then
        ' Lógica corregida para módulos estándar (.bas) - usar Add(1)
        On Error Resume Next
        
        ' Buscar si ya existe un componente con este nombre
        Set vbComponent = Nothing
        For Each existingComponent In objAccess.VBE.ActiveVBProject.VBComponents
            If existingComponent.Name = moduleName Then
                Set vbComponent = existingComponent
                Exit For
            End If
        Next
        
        ' Si no existe, crear nuevo componente
        If vbComponent Is Nothing Then
            Set vbComponent = objAccess.VBE.ActiveVBProject.VBComponents.Add(1) ' 1 = vbext_ct_StdModule
            If Err.Number <> 0 Then
                WScript.Echo "❌ ERROR: No se pudo crear componente estándar para " & moduleName & ": " & Err.Description
                On Error GoTo 0
                Exit Sub
            End If
            
            ' Renombrar inmediatamente después de crear
            vbComponent.Name = moduleName
            renameError = Err.Number
            If renameError <> 0 Then
                WScript.Echo "❌ ERROR: No se pudo renombrar el módulo nuevo a '" & moduleName & "': " & Err.Description & " (Código: " & Err.Number & ")"
                On Error GoTo 0
                Exit Sub
            End If
        Else
            ' Si existe, limpiar el código existente
            If vbComponent.CodeModule.CountOfLines > 0 Then
                vbComponent.CodeModule.DeleteLines 1, vbComponent.CodeModule.CountOfLines
            End If
        End If
        
        ' Insertar el contenido limpio en el módulo de código
        vbComponent.CodeModule.AddFromString cleanedContent
        If Err.Number <> 0 Then
            WScript.Echo "❌ ERROR: No se pudo insertar código en el módulo " & moduleName & ": " & Err.Description
            On Error GoTo 0
            Exit Sub
        End If
        
        On Error GoTo 0
        
        ' Confirmar éxito
        WScript.Echo "✅ Módulo " & moduleName & " importado correctamente"
        
    ElseIf fileExtension = "cls" Then
        ' Lógica específica para módulos de clase (.cls)
        On Error Resume Next
        
        ' Buscar si ya existe un componente con este nombre
        Set vbComponent = Nothing
        For Each existingComponent In objAccess.VBE.ActiveVBProject.VBComponents
            If existingComponent.Name = moduleName Then
                Set vbComponent = existingComponent
                Exit For
            End If
        Next
        
        ' Si no existe, crear nuevo componente
        If vbComponent Is Nothing Then
            Set vbComponent = objAccess.VBE.ActiveVBProject.VBComponents.Add(2) ' 2 = vbext_ct_ClassModule
            If Err.Number <> 0 Then
                WScript.Echo "❌ ERROR: No se pudo crear componente de clase para " & moduleName & ": " & Err.Description
                On Error GoTo 0
                Exit Sub
            End If
            
            ' Renombrar inmediatamente después de crear
            vbComponent.Name = moduleName
            renameError = Err.Number
            If renameError <> 0 Then
                WScript.Echo "❌ ERROR: No se pudo renombrar la clase nueva a '" & moduleName & "': " & Err.Description & " (Código: " & Err.Number & ")"
                On Error GoTo 0
                Exit Sub
            End If
        Else
            ' Si existe, limpiar el código existente
            If vbComponent.CodeModule.CountOfLines > 0 Then
                vbComponent.CodeModule.DeleteLines 1, vbComponent.CodeModule.CountOfLines
            End If
        End If
        
        ' Insertar el contenido limpio en el módulo de código
        vbComponent.CodeModule.AddFromString cleanedContent
        If Err.Number <> 0 Then
            WScript.Echo "❌ ERROR: No se pudo insertar código en la clase " & moduleName & ": " & Err.Description
            On Error GoTo 0
            Exit Sub
        End If
        
        On Error GoTo 0
        
        ' Confirmar éxito
        WScript.Echo "✅ Clase " & moduleName & " importada correctamente"
    End If
End Sub

' Subrutina para re-vincular tablas de Access
Sub RelinkTables()
    Dim strDbPath, strLocalFolder
    
    WScript.Echo "=== INICIANDO RE-VINCULACION DE TABLAS ==="
    
    ' Verificar si se usa el modo --all
    If objArgs.Count >= 2 Then
        If LCase(objArgs(1)) = "--all" Then
            Call RelinkAllDatabases()
            Exit Sub
        End If
    End If
    
    ' Verificar que se proporcionaron los argumentos necesarios para modo manual
    If objArgs.Count < 3 Then
        WScript.Echo "Error: El comando relink requiere argumentos:"
        WScript.Echo "Uso: cscript condor_cli.vbs relink <db_path> <local_folder>"
        WScript.Echo "  o: cscript condor_cli.vbs relink --all"
        WScript.Echo "  db_path: Ruta a la base de datos frontend (.accdb)"
        WScript.Echo "  local_folder: Ruta a la carpeta con las bases de datos locales"
        WScript.Echo "  --all: Re-vincular todas las bases de datos en ./back automáticamente"
        objAccess.Quit
        WScript.Quit 1
    End If
    
    ' Leer argumentos de la línea de comandos
    strDbPath = objArgs(1)
    strLocalFolder = objArgs(2)
    
    WScript.Echo "Base de datos frontend: " & strDbPath
    WScript.Echo "Carpeta de backends locales: " & strLocalFolder
    
    ' Verificar que los paths existen
    If Not objFSO.FileExists(strDbPath) Then
        WScript.Echo "Error: La base de datos frontend no existe: " & strDbPath
        objAccess.Quit
        WScript.Quit 1
    End If
    
    If Not objFSO.FolderExists(strLocalFolder) Then
        WScript.Echo "Error: La carpeta de backends locales no existe: " & strLocalFolder
        objAccess.Quit
        WScript.Quit 1
    End If
    
    WScript.Echo "Funcionalidad de re-vinculación pendiente de implementación."
    WScript.Echo "=== RE-VINCULACION COMPLETADA ==="
End Sub

' Subrutina para re-vincular todas las bases de datos automáticamente
Sub RelinkAllDatabases()
    Dim objBackFolder, objFile
    Dim strBackPath, strDbCount
    Dim dbCount, successCount, errorCount
    Dim strDbName, strPassword
    Dim arrDatabases()
    Dim i
    
    WScript.Echo "=== MODO AUTOMATICO: RE-VINCULANDO TODAS LAS BASES DE DATOS ==="
    
    ' Definir ruta del directorio back
    strBackPath = objFSO.GetAbsolutePathName("back")
    
    ' Verificar que existe el directorio back
    If Not objFSO.FolderExists(strBackPath) Then
        WScript.Echo "Error: El directorio ./back no existe: " & strBackPath
        objAccess.Quit
        WScript.Quit 1
    End If
    
    WScript.Echo "Directorio de backends: " & strBackPath
    
    ' Contar y listar bases de datos .accdb
    Set objBackFolder = objFSO.GetFolder(strBackPath)
    dbCount = 0
    
    ' Redimensionar array para almacenar información de bases de datos
    ReDim arrDatabases(50) ' Máximo 50 bases de datos
    
    For Each objFile In objBackFolder.Files
        If LCase(objFSO.GetExtensionName(objFile.Name)) = "accdb" Then
            strDbName = objFSO.GetBaseName(objFile.Name)
            
            ' Determinar contraseña según el nombre de la base de datos
            If InStr(1, UCase(strDbName), "CONDOR") > 0 Then
                strPassword = "(sin contraseña)"
            Else
                strPassword = "dpddpd"
            End If
            
            ' Almacenar información de la base de datos
            arrDatabases(dbCount) = objFile.Path & "|" & strPassword
            dbCount = dbCount + 1
            
            WScript.Echo "  [" & dbCount & "] " & objFile.Name & " - " & strPassword
        End If
    Next
    
    If dbCount = 0 Then
        WScript.Echo "No se encontraron bases de datos .accdb en el directorio ./back"
        WScript.Echo "=== RE-VINCULACION COMPLETADA ==="
        Exit Sub
    End If
    
    WScript.Echo "Total de bases de datos encontradas: " & dbCount
    WScript.Echo "Iniciando proceso de re-vinculación..."
    WScript.Echo ""
    
    ' Procesar cada base de datos
    successCount = 0
    errorCount = 0
    
    For i = 0 To dbCount - 1
        Dim arrDbInfo
        arrDbInfo = Split(arrDatabases(i), "|")
        
        If UBound(arrDbInfo) >= 1 Then
            Dim strDbPath, strDbPassword
            strDbPath = arrDbInfo(0)
            strDbPassword = arrDbInfo(1)
            
            WScript.Echo "Procesando: " & objFSO.GetFileName(strDbPath)
            
            If RelinkSingleDatabase(strDbPath, strDbPassword, strBackPath) Then
                successCount = successCount + 1
                WScript.Echo "  ✓ Re-vinculación exitosa"
            Else
                errorCount = errorCount + 1
                WScript.Echo "  ❌ Error en re-vinculación"
            End If
            WScript.Echo ""
        End If
    Next
    
    ' Resumen final
    WScript.Echo "=== RESUMEN DE RE-VINCULACION AUTOMATICA ==="
    WScript.Echo "Total procesadas: " & dbCount
    WScript.Echo "Exitosas: " & successCount
    WScript.Echo "Con errores: " & errorCount
    
    If errorCount = 0 Then
        WScript.Echo "✓ Todas las bases de datos fueron re-vinculadas exitosamente"
    Else
        WScript.Echo "⚠️ Algunas bases de datos tuvieron errores durante la re-vinculación"
    End If
    
    WScript.Echo "=== RE-VINCULACION AUTOMATICA COMPLETADA ==="
End Sub

' Función para determinar la contraseña de una base de datos
Function GetDatabasePassword(strDbPath)
    Dim strDbName
    strDbName = objFSO.GetBaseName(strDbPath)
    
    ' Las bases de datos CONDOR no requieren contraseña
    If InStr(1, UCase(strDbName), "CONDOR") > 0 Then
        GetDatabasePassword = ""
    Else
        ' Las demás bases de datos usan 'dpddpd'
        GetDatabasePassword = "dpddpd"
    End If
End Function

' Función para re-vincular una sola base de datos
Function RelinkSingleDatabase(strDbPath, strPassword, strBackPath)
    Dim objDb, objTableDef
    Dim strConnectionString
    Dim linkedTableCount, successCount
    
    On Error Resume Next
    
    ' Abrir la base de datos
    If strPassword = "(sin contraseña)" Then
        Set objDb = objAccess.DBEngine.OpenDatabase(strDbPath)
    Else
        Set objDb = objAccess.DBEngine.OpenDatabase(strDbPath, False, False, ";PWD=" & strPassword)
    End If
    
    If Err.Number <> 0 Then
        WScript.Echo "  Error al abrir base de datos: " & Err.Description
        RelinkSingleDatabase = False
        Err.Clear
        Exit Function
    End If
    
    linkedTableCount = 0
    successCount = 0
    
    ' Recorrer todas las tablas vinculadas
    For Each objTableDef In objDb.TableDefs
        If Len(objTableDef.Connect) > 0 Then
            linkedTableCount = linkedTableCount + 1
            
            ' Extraer el nombre de la base de datos del connect string actual
            Dim strCurrentConnect, strSourceDb, strNewConnect
            strCurrentConnect = objTableDef.Connect
            
            ' Buscar el patrón DATABASE= en el connect string
            Dim intDbStart, intDbEnd, strDbName
            intDbStart = InStr(1, UCase(strCurrentConnect), "DATABASE=")
            
            If intDbStart > 0 Then
                intDbStart = intDbStart + 9 ' Longitud de "DATABASE="
                intDbEnd = InStr(intDbStart, strCurrentConnect, ";")
                
                If intDbEnd = 0 Then intDbEnd = Len(strCurrentConnect) + 1
                
                strSourceDb = Mid(strCurrentConnect, intDbStart, intDbEnd - intDbStart)
                strDbName = objFSO.GetFileName(strSourceDb)
                
                ' Construir nueva ruta local
                Dim strNewDbPath
                strNewDbPath = objFSO.BuildPath(strBackPath, strDbName)
                
                ' Verificar que la base de datos local existe
                If objFSO.FileExists(strNewDbPath) Then
                    ' Construir nuevo connect string
                    strNewConnect = Replace(strCurrentConnect, strSourceDb, strNewDbPath)
                    
                    ' Actualizar la vinculación
                    objTableDef.Connect = strNewConnect
                    objTableDef.RefreshLink
                    
                    If Err.Number = 0 Then
                        successCount = successCount + 1
                        WScript.Echo "    ✓ " & objTableDef.Name & " -> " & strDbName
                    Else
                        WScript.Echo "    ❌ Error en " & objTableDef.Name & ": " & Err.Description
                        Err.Clear
                    End If
                Else
                    WScript.Echo "    ⚠️ Base de datos local no encontrada: " & strDbName
                End If
            Else
                WScript.Echo "    ⚠️ No se pudo extraer DATABASE de: " & objTableDef.Name
            End If
        End If
    Next
    
    ' Cerrar base de datos
    objDb.Close
    Set objDb = Nothing
    
    WScript.Echo "    Tablas vinculadas procesadas: " & linkedTableCount
    WScript.Echo "    Re-vinculaciones exitosas: " & successCount
    
    ' Considerar exitoso si se procesó al menos una tabla correctamente
    RelinkSingleDatabase = (successCount > 0 Or linkedTableCount = 0)
    
    On Error GoTo 0
End Function

' Subrutina para reconstruir completamente el proyecto VBA
' ===================================================================
' SUBRUTINA: UpdateProject
' Descripción: Lógica híbrida - modo automático (sin argumentos) o selectivo (con argumentos)
' Modo Automático: Sincronización incremental automática usando .vba_cache
' Modo Selectivo: Actualización rápida de módulos específicos
' ===================================================================
Sub UpdateProject()
    Dim strModuleList
    strModuleList = ""
    
    ' Verificar si se pasó una lista de módulos como argumento adicional
    If WScript.Arguments.Count > 1 Then
        strModuleList = WScript.Arguments(1)
    End If
    
    If strModuleList = "" Then
        ' Modo Automático: Sincronización incremental automática
        Call UpdateAutomaticMode()
    Else
        ' Modo Selectivo: Actualización rápida y selectiva
        Call UpdateSelectiveMode(strModuleList)
    End If
End Sub

' ===================================================================
' SUBRUTINA: UpdateAutomaticMode
' Descripción: Modo Automático - Sincronización incremental automática
' Lógica: Crear .vba_cache, exportar estado actual, comparar por fecha, sincronizar
' ===================================================================
Sub UpdateAutomaticMode()
    WScript.Echo "=== MODO AUTOMATICO: SINCRONIZACION INCREMENTAL ==="
    WScript.Echo "Iniciando sincronización automática basada en fechas de modificación..."
    
    On Error Resume Next
    
    Dim strCachePath, vbProject
    Dim objCacheFolder, objFile, objSrcFile
    Dim strModuleName, strCacheFile, strSrcFile
    Dim dtCacheDate, dtSrcDate
    Dim syncCount, newCount, modifiedCount, deletedCount
    
    ' Paso 1: Crear carpeta temporal .vba_cache
    strCachePath = objFSO.BuildPath(objFSO.GetParentFolderName(strSourcePath), ".vba_cache")
    WScript.Echo "Creando carpeta temporal: " & strCachePath
    
    If objFSO.FolderExists(strCachePath) Then
        objFSO.DeleteFolder strCachePath, True
    End If
    objFSO.CreateFolder strCachePath
    
    ' Paso 2: Exportar estado actual de módulos VBA a .vba_cache
    WScript.Echo "Exportando estado actual de módulos VBA..."
    Set vbProject = objAccess.VBE.ActiveVBProject
    
    Dim vbComponent, exportPath
    For Each vbComponent In vbProject.VBComponents
        If vbComponent.Type = 1 Or vbComponent.Type = 2 Then ' Módulos estándar y clases
            If vbComponent.Type = 1 Then
                exportPath = objFSO.BuildPath(strCachePath, vbComponent.Name & ".bas")
            Else
                exportPath = objFSO.BuildPath(strCachePath, vbComponent.Name & ".cls")
            End If
            
            vbComponent.Export exportPath
            If Err.Number <> 0 Then
                WScript.Echo "Advertencia al exportar " & vbComponent.Name & ": " & Err.Description
                Err.Clear
            End If
        End If
    Next
    
    ' Paso 3: Comparar archivos de /src con .vba_cache por fecha de modificación
    WScript.Echo "Comparando archivos por fecha de modificación..."
    
    syncCount = 0
    newCount = 0
    modifiedCount = 0
    deletedCount = 0
    
    ' Verificar archivos nuevos y modificados en /src
    If objFSO.FolderExists(strSourcePath) Then
        Set objCacheFolder = objFSO.GetFolder(strSourcePath)
        
        For Each objSrcFile In objCacheFolder.Files
            If LCase(objFSO.GetExtensionName(objSrcFile.Name)) = "bas" Or LCase(objFSO.GetExtensionName(objSrcFile.Name)) = "cls" Then
                strCacheFile = objFSO.BuildPath(strCachePath, objSrcFile.Name)
                
                If objFSO.FileExists(strCacheFile) Then
                    ' Archivo existe en cache, comparar fechas
                    Set objFile = objFSO.GetFile(strCacheFile)
                    If objSrcFile.DateLastModified > objFile.DateLastModified Then
                        ' Archivo modificado en /src
                        WScript.Echo "  Modificado: " & objSrcFile.Name
                        Call UpdateSingleModule(objSrcFile.Name)
                        modifiedCount = modifiedCount + 1
                        syncCount = syncCount + 1
                    End If
                Else
                    ' Archivo nuevo en /src
                    WScript.Echo "  Nuevo: " & objSrcFile.Name
                    Call UpdateSingleModule(objSrcFile.Name)
                    newCount = newCount + 1
                    syncCount = syncCount + 1
                End If
            End If
        Next
    End If
    
    ' Verificar archivos eliminados (existen en cache pero no en /src)
    If objFSO.FolderExists(strCachePath) Then
        Set objCacheFolder = objFSO.GetFolder(strCachePath)
        
        For Each objFile In objCacheFolder.Files
            If LCase(objFSO.GetExtensionName(objFile.Name)) = "bas" Or LCase(objFSO.GetExtensionName(objFile.Name)) = "cls" Then
                strSrcFile = objFSO.BuildPath(strSourcePath, objFile.Name)
                
                If Not objFSO.FileExists(strSrcFile) Then
                    ' Archivo eliminado de /src, eliminar de VBA
                    strModuleName = objFSO.GetBaseName(objFile.Name)
                    WScript.Echo "  Eliminado: " & objFile.Name
                    Call RemoveSingleModule(strModuleName)
                    deletedCount = deletedCount + 1
                    syncCount = syncCount + 1
                End If
            End If
        Next
    End If
    
    ' Paso 4: Eliminar carpeta temporal .vba_cache
    WScript.Echo "Eliminando carpeta temporal..."
    If objFSO.FolderExists(strCachePath) Then
        objFSO.DeleteFolder strCachePath, True
    End If
    
    ' Guardar cambios
    If syncCount > 0 Then
        WScript.Echo "Guardando cambios en Access..."
        For Each vbComponent In vbProject.VBComponents
            If vbComponent.Type = 1 Then  ' vbext_ct_StdModule
                objAccess.DoCmd.Save 5, vbComponent.Name  ' acModule = 5
                If Err.Number <> 0 Then
                    WScript.Echo "Advertencia al guardar " & vbComponent.Name & ": " & Err.Description
                    Err.Clear
                End If
            ElseIf vbComponent.Type = 2 Then  ' vbext_ct_ClassModule
                objAccess.DoCmd.Save 7, vbComponent.Name  ' acClassModule = 7
                If Err.Number <> 0 Then
                    WScript.Echo "Advertencia al guardar " & vbComponent.Name & ": " & Err.Description
                    Err.Clear
                End If
            End If
        Next
    End If
    
    WScript.Echo "=== SINCRONIZACION AUTOMATICA COMPLETADA ==="
    WScript.Echo "Archivos nuevos: " & newCount
    WScript.Echo "Archivos modificados: " & modifiedCount
    WScript.Echo "Archivos eliminados: " & deletedCount
    WScript.Echo "Total sincronizado: " & syncCount
    
    If syncCount = 0 Then
        WScript.Echo "✓ Todos los módulos estaban sincronizados"
    Else
        WScript.Echo "✓ Sincronización automática exitosa"
    End If
    
    On Error GoTo 0
End Sub

' ===================================================================
' SUBRUTINA: UpdateSelectiveMode
' Descripción: Modo Selectivo - Actualización rápida de módulos específicos
' ===================================================================
Sub UpdateSelectiveMode(strModuleList)
    WScript.Echo "=== MODO SELECTIVO: ACTUALIZACION RAPIDA ==="
    WScript.Echo "Módulos a actualizar: " & strModuleList
    
    On Error Resume Next
    
    Dim arrModules, i
    Dim strModuleName
    Dim updatedCount, processedCount
    
    ' Dividir la lista de módulos
    arrModules = Split(strModuleList, ",")
    
    updatedCount = 0
    processedCount = 0
    
    ' Procesar cada módulo de la lista
    For i = 0 To UBound(arrModules)
        strModuleName = Trim(arrModules(i))
        
        If strModuleName <> "" Then
            processedCount = processedCount + 1
            WScript.Echo "Procesando módulo: " & strModuleName
            
            ' Eliminar el componente y reimportarlo
            If UpdateSingleModuleSelective(strModuleName) Then
                updatedCount = updatedCount + 1
            End If
        End If
    Next
    
    WScript.Echo "=== MODO SELECTIVO COMPLETADO ==="
    WScript.Echo "Módulos procesados: " & processedCount
    WScript.Echo "Módulos actualizados: " & updatedCount
    
    If updatedCount = 0 Then
        WScript.Echo "⚠️ Ningún módulo fue actualizado"
    Else
        WScript.Echo "✓ Actualización selectiva exitosa"
    End If
    
    On Error GoTo 0
End Sub

' ===================================================================
' SUBRUTINA: UpdateSingleModule
' Descripción: Actualiza un solo módulo (usado por modo automático)
' ===================================================================
Sub UpdateSingleModule(strFileName)
    On Error Resume Next
    
    Dim strModuleName, strFilePath, fileExtension
    Dim vbProject, vbComponent, componentFound
    Dim cleanedContent
    
    strModuleName = objFSO.GetBaseName(strFileName)
    strFilePath = objFSO.BuildPath(strSourcePath, strFileName)
    fileExtension = LCase(objFSO.GetExtensionName(strFileName))
    
    If Not objFSO.FileExists(strFilePath) Then
        WScript.Echo "    ⚠️ Archivo no encontrado: " & strFileName
        Exit Sub
    End If
    
    Set vbProject = objAccess.VBE.ActiveVBProject
    
    ' Buscar y eliminar el componente existente (solo si existe)
    componentFound = False
    For Each vbComponent In vbProject.VBComponents
        If vbComponent.Name = strModuleName Then
            componentFound = True
            WScript.Echo "    Eliminando componente existente: " & strModuleName
            vbProject.VBComponents.Remove vbComponent
            
            If Err.Number <> 0 Then
                WScript.Echo "    ❌ Error eliminando componente: " & Err.Description
                Err.Clear
            Else
                WScript.Echo "    ✓ Componente eliminado correctamente"
            End If
            Exit For
        End If
    Next
    
    If Not componentFound Then
        WScript.Echo "    -> Componente no existe en destino, creando nuevo"
    End If
    
    ' Leer y limpiar el contenido del archivo
    cleanedContent = ReadAndCleanVBAFile(strFilePath)
    
    ' Importar el módulo
    If fileExtension = "bas" Then
        Set vbComponent = vbProject.VBComponents.Import(strFilePath)
    ElseIf fileExtension = "cls" Then
        Set vbComponent = vbProject.VBComponents.Import(strFilePath)
    End If
    
    If Err.Number <> 0 Then
        WScript.Echo "    ⚠️ Error al importar " & strFileName & ": " & Err.Description
        Err.Clear
    Else
        WScript.Echo "    ✓ Actualizado: " & strModuleName
    End If
    
    On Error GoTo 0
End Sub

' ===================================================================
' SUBRUTINA: RemoveSingleModule
' Descripción: Elimina un solo módulo (usado por modo automático)
' ===================================================================
Sub RemoveSingleModule(strModuleName)
    On Error Resume Next
    
    Dim vbProject, vbComponent
    
    Set vbProject = objAccess.VBE.ActiveVBProject
    
    ' Buscar y eliminar el componente
    For Each vbComponent In vbProject.VBComponents
        If vbComponent.Name = strModuleName Then
            vbProject.VBComponents.Remove vbComponent
            WScript.Echo "    ✓ Eliminado: " & strModuleName
            Exit Sub
        End If
    Next
    
    WScript.Echo "    ⚠️ Módulo no encontrado para eliminar: " & strModuleName
    
    On Error GoTo 0
End Sub

' ===================================================================
' SUBRUTINA: UpdateSingleModuleSelective
' Descripción: Actualiza un solo módulo para modo selectivo (retorna éxito)
' CORREGIDO: Implementa secuencia correcta "eliminar y luego importar"
' ===================================================================
Function UpdateSingleModuleSelective(strModuleName)
    On Error Resume Next
    
    Dim strFileName, strFilePath, fileExtension
    Dim vbProject, vbComponent, componentFound
    Dim cleanedContent
    
    UpdateSingleModuleSelective = False
    
    ' Buscar el archivo correspondiente (.bas o .cls)
    strFileName = ""
    If objFSO.FileExists(objFSO.BuildPath(strSourcePath, strModuleName & ".bas")) Then
        strFileName = objFSO.BuildPath(strSourcePath, strModuleName & ".bas")
        fileExtension = "bas"
    ElseIf objFSO.FileExists(objFSO.BuildPath(strSourcePath, strModuleName & ".cls")) Then
        strFileName = objFSO.BuildPath(strSourcePath, strModuleName & ".cls")
        fileExtension = "cls"
    End If
    
    If strFileName = "" Then
        WScript.Echo "    ⚠️ Archivo no encontrado: " & strModuleName & ".bas/.cls"
        Exit Function
    End If
    
    WScript.Echo "    -> Archivo encontrado: " & objFSO.GetFileName(strFileName)
    
    Set vbProject = objAccess.VBE.ActiveVBProject
    
    ' PASO 1: Buscar y eliminar el componente existente (solo si existe)
    componentFound = False
    For Each vbComponent In vbProject.VBComponents
        If vbComponent.Name = strModuleName Then
            componentFound = True
            WScript.Echo "    Eliminando componente existente: " & strModuleName
            vbProject.VBComponents.Remove vbComponent
            
            If Err.Number <> 0 Then
                WScript.Echo "    ❌ Error eliminando componente: " & Err.Description
                Err.Clear
                Exit Function
            Else
                WScript.Echo "    ✓ Componente eliminado correctamente"
            End If
            Exit For
        End If
    Next
    
    If Not componentFound Then
        WScript.Echo "    -> Componente no existe en destino, creando nuevo"
    End If
    
    ' PASO 2: Leer y limpiar el contenido del archivo
    cleanedContent = CleanVBAFile(strFileName, fileExtension)
    
    If Err.Number <> 0 Then
        WScript.Echo "    ❌ Error al limpiar archivo: " & Err.Description
        Err.Clear
        Exit Function
    End If
    
    ' PASO 3: Importar el módulo usando ImportModuleWithAnsiEncoding
    WScript.Echo "    Importando módulo..."
    Call ImportModuleWithAnsiEncoding(strFileName, strModuleName, fileExtension, Nothing, cleanedContent)
    
    If Err.Number <> 0 Then
        WScript.Echo "    ❌ Error al importar " & strModuleName & ": " & Err.Description
        Err.Clear
        Exit Function
    Else
        WScript.Echo "    ✓ Módulo actualizado exitosamente: " & strModuleName
        UpdateSingleModuleSelective = True
    End If
    
    On Error GoTo 0
End Function

' ===================================================================
' SUBRUTINA: SyncModules
' Descripción: Subrutina genérica para sincronizar módulos VBA
' Parámetros: moduleNames - Array o colección de nombres de módulos
' ===================================================================
Sub SyncModules(moduleNames)
    On Error Resume Next
    
    Dim vbProject, vbComponent, componentFound
    Dim strModuleName, strFileName, fileExtension
    Dim cleanedContent
    Dim i, moduleCount
    
    Set vbProject = objAccess.VBE.ActiveVBProject
    
    ' Determinar si es un array o una colección
    If IsArray(moduleNames) Then
        moduleCount = UBound(moduleNames)
    Else
        moduleCount = moduleNames.Count - 1
    End If
    
    ' Procesar cada módulo
    For i = 0 To moduleCount
        If IsArray(moduleNames) Then
            strModuleName = Trim(moduleNames(i))
        Else
            strModuleName = Trim(moduleNames(i + 1))
        End If
        
        If strModuleName <> "" Then
            WScript.Echo "Sincronizando módulo: " & strModuleName
            
            ' PASO 1: Buscar y eliminar el componente VBA existente (solo si existe)
            componentFound = False
            For Each vbComponent In vbProject.VBComponents
                If vbComponent.Name = strModuleName Then
                    componentFound = True
                    WScript.Echo "    Eliminando componente existente: " & strModuleName
                    vbProject.VBComponents.Remove vbComponent
                    
                    If Err.Number <> 0 Then
                        WScript.Echo "    ❌ Error eliminando componente: " & Err.Description
                        Err.Clear
                    Else
                        WScript.Echo "    ✓ Componente eliminado correctamente"
                    End If
                    Exit For
                End If
            Next
            
            If Not componentFound Then
                WScript.Echo "    -> Componente no existe en destino, creando nuevo"
            End If
            
            ' PASO 2: Localizar el fichero fuente (.bas o .cls) en /src
            strFileName = ""
            If objFSO.FileExists(objFSO.BuildPath(strSourcePath, strModuleName & ".bas")) Then
                strFileName = objFSO.BuildPath(strSourcePath, strModuleName & ".bas")
                fileExtension = "bas"
            ElseIf objFSO.FileExists(objFSO.BuildPath(strSourcePath, strModuleName & ".cls")) Then
                strFileName = objFSO.BuildPath(strSourcePath, strModuleName & ".cls")
                fileExtension = "cls"
            End If
            
            If strFileName = "" Then
                WScript.Echo "    ⚠️ Archivo no encontrado: " & strModuleName & ".bas/.cls"
            Else
                WScript.Echo "    -> Archivo encontrado: " & objFSO.GetFileName(strFileName)
                
                ' PASO 3: Limpiar el contenido del fichero
                cleanedContent = CleanVBAFile(strFileName, fileExtension)
                
                If Err.Number <> 0 Then
                    WScript.Echo "    ❌ Error al limpiar archivo: " & Err.Description
                    Err.Clear
                Else
                    ' PASO 4: Importar el módulo con contenido limpio
                    WScript.Echo "    Importando módulo..."
                    Call ImportModuleWithAnsiEncoding(strFileName, strModuleName, fileExtension, Nothing, cleanedContent)
                    
                    If Err.Number <> 0 Then
                        WScript.Echo "    ❌ Error al importar " & strModuleName & ": " & Err.Description
                        Err.Clear
                    Else
                        WScript.Echo "    ✓ Módulo sincronizado exitosamente: " & strModuleName
                    End If
                End If
            End If
        End If
    Next
    
    On Error GoTo 0
End Sub

' ===================================================================
' SUBRUTINA LEGACY: UpdateSpecificModules (mantenida para compatibilidad)
' ===================================================================
Sub UpdateSpecificModules(strModuleList)
    WScript.Echo "=== ACTUALIZACION SELECTIVA DE MODULOS ==="
    WScript.Echo "Modulos a actualizar: " & strModuleList
    
    On Error Resume Next
    
    Dim arrModules
    Dim vbProject, vbComponent
    Dim updatedCount, processedCount
    
    ' Dividir la lista de módulos
    arrModules = Split(strModuleList, ",")
    
    Set vbProject = objAccess.VBE.ActiveVBProject
    
    If Not objFSO.FolderExists(strSourcePath) Then
        WScript.Echo "Error: Directorio de origen no existe: " & strSourcePath
        WScript.Quit 1
    End If
    
    ' Llamar a la nueva subrutina genérica SyncModules
    Call SyncModules(arrModules)
    
    ' Contar módulos procesados para estadísticas
    processedCount = 0
    updatedCount = 0
    Dim i
    For i = 0 To UBound(arrModules)
        If Trim(arrModules(i)) <> "" Then
            processedCount = processedCount + 1
            ' Verificar si el módulo existe en el proyecto VBA
            For Each vbComponent In vbProject.VBComponents
                If vbComponent.Name = Trim(arrModules(i)) Then
                    updatedCount = updatedCount + 1
                    Exit For
                End If
            Next
        End If
    Next
    
    ' Guardar módulos actualizados
    If updatedCount > 0 Then
        WScript.Echo "Guardando modulos actualizados..."
        
        For Each vbComponent In vbProject.VBComponents
            If vbComponent.Type = 1 Then  ' vbext_ct_StdModule
                objAccess.DoCmd.Save 5, vbComponent.Name  ' acModule = 5
                If Err.Number <> 0 Then
                    WScript.Echo "Advertencia al guardar " & vbComponent.Name & ": " & Err.Description
                    Err.Clear
                End If
            ElseIf vbComponent.Type = 2 Then  ' vbext_ct_ClassModule
                objAccess.DoCmd.Save 7, vbComponent.Name  ' acClassModule = 7
                If Err.Number <> 0 Then
                    WScript.Echo "Advertencia al guardar " & vbComponent.Name & ": " & Err.Description
                    Err.Clear
                End If
            End If
        Next
    End If
    
    WScript.Echo "=== ACTUALIZACION SELECTIVA COMPLETADA ==="
    WScript.Echo "Modulos procesados: " & processedCount
    WScript.Echo "Modulos actualizados: " & updatedCount
    
    If updatedCount = 0 Then
        WScript.Echo "⚠️ Ningun modulo fue actualizado"
    Else
        WScript.Echo "✓ Actualizacion selectiva exitosa"
    End If
    
    On Error GoTo 0
End Sub

' ===================================================================
' SUBRUTINA: UpdateAllModules
' Descripción: Actualiza todos los módulos (comportamiento anterior)
' ===================================================================
Sub UpdateAllModules()
    WScript.Echo "=== ACTUALIZACION COMPLETA DEL PROYECTO VBA ==="
    WScript.Echo "Actualizando todos los modulos del directorio /src..."
    
    On Error Resume Next
    
    Dim objFolder, objFile
    Dim strFileName, strModuleName, fileExtension
    Dim vbProject, vbComponent
    Dim updatedCount, totalFiles
    Dim cleanedContent
    
    Set vbProject = objAccess.VBE.ActiveVBProject
    
    If Not objFSO.FolderExists(strSourcePath) Then
        WScript.Echo "Error: Directorio de origen no existe: " & strSourcePath
        WScript.Quit 1
    End If
    
    Set objFolder = objFSO.GetFolder(strSourcePath)
    updatedCount = 0
    totalFiles = 0
    
    For Each objFile In objFolder.Files
        If LCase(objFSO.GetExtensionName(objFile.Name)) = "bas" Or LCase(objFSO.GetExtensionName(objFile.Name)) = "cls" Then
            totalFiles = totalFiles + 1
            strFileName = objFile.Path
            strModuleName = objFSO.GetBaseName(objFile.Name)
            fileExtension = LCase(objFSO.GetExtensionName(objFile.Name))
            
            WScript.Echo "Procesando: " & strModuleName
            
            ' Buscar el componente VBA correspondiente
            Set vbComponent = Nothing
            Dim componentFound
            componentFound = False
            
            For Each vbComponent In vbProject.VBComponents
                If vbComponent.Name = strModuleName Then
                    componentFound = True
                    Exit For
                End If
            Next
            
            ' Eliminar componente existente si existe
            If componentFound Then
                WScript.Echo "  Eliminando componente existente..."
                vbProject.VBComponents.Remove vbComponent
                
                If Err.Number <> 0 Then
                    WScript.Echo "  Error eliminando componente: " & Err.Description
                    Err.Clear
                Else
                    WScript.Echo "  ✓ Componente eliminado"
                End If
            End If
            
            ' Limpiar archivo antes de importar
            cleanedContent = CleanVBAFile(strFileName, fileExtension)
            
            ' Importar el archivo
            WScript.Echo "  Importando archivo..."
            Call ImportModuleWithAnsiEncoding(strFileName, strModuleName, fileExtension, Nothing, cleanedContent)
            
            If Err.Number <> 0 Then
                WScript.Echo "  Error al importar: " & Err.Description
                Err.Clear
            Else
                WScript.Echo "  ✓ Modulo actualizado exitosamente"
                updatedCount = updatedCount + 1
            End If
        End If
    Next
    
    ' Guardar módulos actualizados
    If updatedCount > 0 Then
        WScript.Echo "Guardando modulos actualizados..."
        
        For Each vbComponent In vbProject.VBComponents
            If vbComponent.Type = 1 Then  ' vbext_ct_StdModule
                objAccess.DoCmd.Save 5, vbComponent.Name  ' acModule = 5
                If Err.Number <> 0 Then
                    WScript.Echo "Advertencia al guardar " & vbComponent.Name & ": " & Err.Description
                    Err.Clear
                End If
            ElseIf vbComponent.Type = 2 Then  ' vbext_ct_ClassModule
                objAccess.DoCmd.Save 7, vbComponent.Name  ' acClassModule = 7
                If Err.Number <> 0 Then
                    WScript.Echo "Advertencia al guardar " & vbComponent.Name & ": " & Err.Description
                    Err.Clear
                End If
            End If
        Next
    End If
    
    WScript.Echo "=== ACTUALIZACION COMPLETA COMPLETADA ==="
    WScript.Echo "Archivos procesados: " & totalFiles
    WScript.Echo "Modulos actualizados: " & updatedCount
    
    If updatedCount = 0 Then
        WScript.Echo "✓ Todos los modulos estaban actualizados"
    Else
        WScript.Echo "✓ Actualizacion completa exitosa"
    End If
    
    On Error GoTo 0
End Sub

Sub RebuildProject()
    WScript.Echo "=== RECONSTRUCCION COMPLETA DEL PROYECTO VBA ==="
    WScript.Echo "ADVERTENCIA: Se eliminaran TODOS los modulos VBA existentes"
    WScript.Echo "Iniciando proceso de reconstruccion..."
    
    On Error Resume Next
    
    ' Paso 1: Eliminar todos los módulos existentes
    WScript.Echo "Paso 1: Eliminando todos los modulos VBA existentes..."
    
    Dim vbProject, vbComponent
    Set vbProject = objAccess.VBE.ActiveVBProject
    
    Dim componentCount, i, errorDetails
    componentCount = vbProject.VBComponents.Count
    
    ' Iterar hacia atrás para evitar problemas al eliminar elementos
    For i = componentCount To 1 Step -1
        Set vbComponent = vbProject.VBComponents(i)
        
        ' Solo eliminar módulos estándar y de clase (no formularios ni informes)
        If vbComponent.Type = 1 Or vbComponent.Type = 2 Then ' vbext_ct_StdModule = 1, vbext_ct_ClassModule = 2
            WScript.Echo "  Eliminando: " & vbComponent.Name & " (Tipo: " & vbComponent.Type & ")"
            vbProject.VBComponents.Remove vbComponent
            
            If Err.Number <> 0 Then
                WScript.Echo "  ❌ Error eliminando " & vbComponent.Name & ": " & Err.Description
                Err.Clear
            Else
                WScript.Echo "  ✓ Eliminado: " & vbComponent.Name
            End If
        End If
    Next
    
    WScript.Echo "Paso 2: Guardando y cerrando base de datos..."
    
    ' Forzar guardado y cierre
    objAccess.DoCmd.Save
    objAccess.Quit 1  ' acQuitSaveAll = 1
    
    If Err.Number <> 0 Then
        WScript.Echo "Advertencia al cerrar Access: " & Err.Description
        Err.Clear
    End If
    
    Set objAccess = Nothing
    WScript.Echo "✓ Base de datos cerrada y guardada"
    
    ' Paso 3: Volver a abrir la base de datos
    WScript.Echo "Paso 3: Reabriendo base de datos con proyecto VBA limpio..."
    
    Set objAccess = CreateObject("Access.Application")
    
    If Err.Number <> 0 Then
        WScript.Echo "❌ Error al crear nueva instancia de Access: " & Err.Description
        WScript.Quit 1
    End If
    
    ' Configurar Access en modo silencioso
    objAccess.Visible = False
    objAccess.UserControl = False
    
    ' Suprimir alertas y diálogos de confirmación
    On Error Resume Next
    objAccess.DoCmd.SetWarnings False
    objAccess.Application.Echo False
    objAccess.DisplayAlerts = False
    ' Configuraciones adicionales para suprimir diálogos
    objAccess.Application.AutomationSecurity = 1  ' msoAutomationSecurityLow
    objAccess.VBE.MainWindow.Visible = False
    Err.Clear
    On Error GoTo 0
    
    ' Determinar contraseña para la base de datos
    Dim strDbPassword
    strDbPassword = GetDatabasePassword(strAccessPath)
    
    ' Abrir base de datos
    If strDbPassword = "" Then
        objAccess.OpenCurrentDatabase strAccessPath
    Else
        objAccess.OpenCurrentDatabase strAccessPath, , strDbPassword
    End If
    
    If Err.Number <> 0 Then
        WScript.Echo "❌ Error al reabrir base de datos: " & Err.Description
        WScript.Quit 1
    End If
    
    WScript.Echo "✓ Base de datos reabierta con proyecto VBA limpio"
    
    ' Paso 4: Importar todos los módulos de nuevo
    WScript.Echo "Paso 4: Importando todos los modulos desde /src..."
    
    ' Integrar lógica de importación directamente
    Dim objFolder, objFile
    Dim moduleExists
    Dim validationResult
    Dim totalFiles, validFiles, invalidFiles
    Dim allModuleNames()
    Dim moduleCount
    
    If Not objFSO.FolderExists(strSourcePath) Then
        WScript.Echo "Error: Directorio de origen no existe: " & strSourcePath
        objAccess.Quit
        WScript.Quit 1
    End If
    
    ' PASO 4.1: Validacion previa de sintaxis
    WScript.Echo "Validando sintaxis de todos los modulos..."
    Set objFolder = objFSO.GetFolder(strSourcePath)
    totalFiles = 0
    validFiles = 0
    invalidFiles = 0
    
    For Each objFile In objFolder.Files
        If LCase(objFSO.GetExtensionName(objFile.Name)) = "bas" Or LCase(objFSO.GetExtensionName(objFile.Name)) = "cls" Then
            totalFiles = totalFiles + 1
            validationResult = ValidateVBASyntax(objFile.Path, errorDetails)
            
            If validationResult = True Then
                validFiles = validFiles + 1
                WScript.Echo "  ✓ " & objFile.Name & " - Sintaxis valida"
            Else
                invalidFiles = invalidFiles + 1
                WScript.Echo "  ✗ ERROR en " & objFile.Name & ": " & errorDetails
            End If
        End If
    Next
    
    If invalidFiles > 0 Then
        WScript.Echo "ABORTANDO: Se encontraron " & invalidFiles & " archivos con errores de sintaxis."
        WScript.Echo "Use 'cscript condor_cli.vbs validate --verbose' para más detalles."
        objAccess.Quit
        WScript.Quit 1
    End If
    
    WScript.Echo "✓ Validacion completada: " & validFiles & " archivos validos"
    
    ' PASO 4.2: Crear colección con todos los nombres de módulos
    moduleCount = 0
    ReDim allModuleNames(totalFiles - 1)
    
    For Each objFile In objFolder.Files
        If LCase(objFSO.GetExtensionName(objFile.Name)) = "bas" Or LCase(objFSO.GetExtensionName(objFile.Name)) = "cls" Then
            allModuleNames(moduleCount) = objFSO.GetBaseName(objFile.Name)
            moduleCount = moduleCount + 1
        End If
    Next
    
    ' Redimensionar el array al tamaño correcto
    If moduleCount > 0 Then
        ReDim Preserve allModuleNames(moduleCount - 1)
        
        ' PASO 4.3: Llamar a SyncModules con todos los módulos
        WScript.Echo "Sincronizando todos los modulos usando SyncModules..."
        Call SyncModules(allModuleNames)
    End If
    
    ' PASO 4.3: Guardar cada modulo individualmente
    WScript.Echo "Guardando modulos individualmente..."
    On Error Resume Next
    
    For Each vbComponent In objAccess.VBE.ActiveVBProject.VBComponents
        If vbComponent.Type = 1 Then  ' vbext_ct_StdModule
            WScript.Echo "Guardando modulo: " & vbComponent.Name
            objAccess.DoCmd.Save 5, vbComponent.Name  ' acModule = 5
            If Err.Number <> 0 Then
                WScript.Echo "Advertencia al guardar " & vbComponent.Name & ": " & Err.Description
                Err.Clear
            End If
        ElseIf vbComponent.Type = 2 Then  ' vbext_ct_ClassModule
            WScript.Echo "Guardando clase: " & vbComponent.Name
            objAccess.DoCmd.Save 7, vbComponent.Name  ' acClassModule = 7
            If Err.Number <> 0 Then
                WScript.Echo "Advertencia al guardar " & vbComponent.Name & ": " & Err.Description
                Err.Clear
            End If
        End If
    Next
    
    ' PASO 4.4: Verificacion de integridad y compilacion
    WScript.Echo "Verificando integridad de nombres de modulos..."
    Call VerifyModuleNames()
    
    WScript.Echo "=== RECONSTRUCCION COMPLETADA EXITOSAMENTE ==="
    WScript.Echo "El proyecto VBA ha sido completamente reconstruido"
    WScript.Echo "Todos los modulos han sido reimportados desde /src"
    
    On Error GoTo 0
End Sub

' Subrutina para compilar el proyecto VBA con verificaciones defensivas
Sub CompileProject()
    WScript.Echo "=== INICIANDO COMPILACION COMPLETA DEL PROYECTO VBA ==="

    ' --- Verificación Defensiva ---
    If objAccess Is Nothing Then
        WScript.Echo "ERROR CRITICO: El objeto de la aplicación Access no es válido (Nothing)."
        WScript.Quit 1
    End If

    On Error Resume Next
    If objAccess.CurrentDb Is Nothing Then
        WScript.Echo "ERROR CRITICO: No hay ninguna base de datos abierta en la instancia de Access."
        objAccess.Quit
        WScript.Quit 1
    End If
    On Error GoTo 0
    ' --- Fin de la Verificación ---

    WScript.Echo "Instancia de Access y base de datos validadas. Intentando compilar..."

    On Error Resume Next
    Err.Clear

    ' Comando para compilar y guardar todos los módulos.
    objAccess.DoCmd.RunCommand 584 ' acCmdCompileAndSaveAllModules

    If Err.Number <> 0 Then
        WScript.Echo "--------------------------------------------------"
        WScript.Echo "ERROR DE COMPILACION DETECTADO:"
        WScript.Echo "  Código de Error: " & Err.Number
        WScript.Echo "  Descripción: " & Err.Description
        WScript.Echo "--------------------------------------------------"
        WScript.Echo "ACCION REQUERIDA: Abre Access, ve al editor de VBA (Alt+F11) y selecciona 'Depuración -> Compilar' para localizar el error."
        Err.Clear
        objAccess.Quit
        WScript.Quit 1 ' Salir con código de error
    Else
        WScript.Echo "✓ Compilación completada exitosamente. No se encontraron errores."
        ' Dejamos que el script principal se encargue de cerrar Access.
    End If

    On Error GoTo 0
End Sub

' Subrutina para verificar y cerrar procesos de Access existentes
Sub CloseExistingAccessProcesses()
    Dim objWMI, colProcesses, objProcess
    Dim processCount
    
    WScript.Echo "Verificando procesos de Access existentes..."
    
    On Error Resume Next
    Set objWMI = GetObject("winmgmts:")
    Set colProcesses = objWMI.ExecQuery("SELECT * FROM Win32_Process WHERE Name = 'MSACCESS.EXE'")
    
    processCount = 0
    For Each objProcess In colProcesses
        processCount = processCount + 1
    Next
    
    If processCount > 0 Then
        WScript.Echo "Se encontraron " & processCount & " procesos de Access ejecutándose. Cerrándolos..."
        
        For Each objProcess In colProcesses
            WScript.Echo "Terminando proceso Access PID: " & objProcess.ProcessId
            objProcess.Terminate()
        Next
        
        ' Esperar un momento para que los procesos se cierren completamente
        WScript.Sleep 2000
        WScript.Echo "✓ Procesos de Access cerrados correctamente"
    Else
        WScript.Echo "✓ No se encontraron procesos de Access ejecutándose"
    End If
    
    On Error GoTo 0
End Sub

' La subrutina ExecuteTestModule ha sido eliminada ya que ahora se usa el motor interno modTestRunner
